<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Symbolic Mathematics Library (SML): Abstract Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Symbolic Mathematics Library (SML)
   </div>
   <div id="projectbrief">Symbolic calculation package for quantum field theory</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Abstract Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><b>Root</b> class of the inheritance tree of abstracts.  
 <a href="classAbstract.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="abstract_8h_source.html">abstract.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Abstract:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classAbstract__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc6e3314f7cec8a356e1ee6a9dde1d18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#acc6e3314f7cec8a356e1ee6a9dde1d18">Abstract</a> ()</td></tr>
<tr class="memdesc:acc6e3314f7cec8a356e1ee6a9dde1d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#acc6e3314f7cec8a356e1ee6a9dde1d18">More...</a><br /></td></tr>
<tr class="separator:acc6e3314f7cec8a356e1ee6a9dde1d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738cc29f2abe8567c3f132198014e753"><td class="memItemLeft" align="right" valign="top"><a id="a738cc29f2abe8567c3f132198014e753"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a738cc29f2abe8567c3f132198014e753">Abstract</a> (const std::string &amp;t_name)</td></tr>
<tr class="memdesc:a738cc29f2abe8567c3f132198014e753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name to t_name and commutable to <b>True</b>. <br /></td></tr>
<tr class="separator:a738cc29f2abe8567c3f132198014e753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ef9b71019b8c2c3b9133497349262e"><td class="memItemLeft" align="right" valign="top"><a id="a67ef9b71019b8c2c3b9133497349262e"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a67ef9b71019b8c2c3b9133497349262e">~Abstract</a> ()</td></tr>
<tr class="memdesc:a67ef9b71019b8c2c3b9133497349262e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a67ef9b71019b8c2c3b9133497349262e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0580f5b543391148404278629c495668"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a0580f5b543391148404278629c495668">print</a> (int mode=0) const =0</td></tr>
<tr class="memdesc:a0580f5b543391148404278629c495668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the abstract in standard output.  <a href="#a0580f5b543391148404278629c495668">More...</a><br /></td></tr>
<tr class="separator:a0580f5b543391148404278629c495668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f86250bd135d34203d40020a6c9b56f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8f86250bd135d34203d40020a6c9b56f">printExplicit</a> (int mode=0) const</td></tr>
<tr class="memdesc:a8f86250bd135d34203d40020a6c9b56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays explicitely the expression, with types of each component. This function is only used for debug.  <a href="#a8f86250bd135d34203d40020a6c9b56f">More...</a><br /></td></tr>
<tr class="separator:a8f86250bd135d34203d40020a6c9b56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21ac36bebac371e07ca725f91c9a21c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#af21ac36bebac371e07ca725f91c9a21c">printLaTeX</a> (int mode=0) const</td></tr>
<tr class="memdesc:af21ac36bebac371e07ca725f91c9a21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a LaTeX output for the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#af21ac36bebac371e07ca725f91c9a21c">More...</a><br /></td></tr>
<tr class="separator:af21ac36bebac371e07ca725f91c9a21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a60438a5b55d0b2ceb35c8674b9d8c5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8a60438a5b55d0b2ceb35c8674b9d8c5">getName</a> () const</td></tr>
<tr class="memdesc:a8a60438a5b55d0b2ceb35c8674b9d8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>'s name.  <a href="#a8a60438a5b55d0b2ceb35c8674b9d8c5">More...</a><br /></td></tr>
<tr class="separator:a8a60438a5b55d0b2ceb35c8674b9d8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008f58643c15d4f624e6aee7a98e699c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a008f58643c15d4f624e6aee7a98e699c">getCommutable</a> () const</td></tr>
<tr class="memdesc:a008f58643c15d4f624e6aee7a98e699c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to know if the object commutes with all the others.  <a href="#a008f58643c15d4f624e6aee7a98e699c">More...</a><br /></td></tr>
<tr class="separator:a008f58643c15d4f624e6aee7a98e699c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ca7706d5195bafe639907377239b30"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a8e2e97c94555dae36453ba3c507db79e">smType::PrimaryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ae8ca7706d5195bafe639907377239b30">getPrimaryType</a> () const =0</td></tr>
<tr class="memdesc:ae8ca7706d5195bafe639907377239b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>primary</b> <b>type</b> of <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#ae8ca7706d5195bafe639907377239b30">More...</a><br /></td></tr>
<tr class="separator:ae8ca7706d5195bafe639907377239b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac545afdeb8b1724b1e8aff98b059b52c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a1d1cfd8ffb84e947f82999c682b666a7">smType::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ac545afdeb8b1724b1e8aff98b059b52c">getType</a> () const =0</td></tr>
<tr class="memdesc:ac545afdeb8b1724b1e8aff98b059b52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>type</b> of <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#ac545afdeb8b1724b1e8aff98b059b52c">More...</a><br /></td></tr>
<tr class="separator:ac545afdeb8b1724b1e8aff98b059b52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08975678f3024274380d3502839b0d10"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a08975678f3024274380d3502839b0d10">getDim</a> () const =0</td></tr>
<tr class="memdesc:a08975678f3024274380d3502839b0d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>dimension</b> of the object.  <a href="#a08975678f3024274380d3502839b0d10">More...</a><br /></td></tr>
<tr class="separator:a08975678f3024274380d3502839b0d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134526a9e561b38741398c32f76c91b8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a134526a9e561b38741398c32f76c91b8">isBuildingBlock</a> () const</td></tr>
<tr class="memdesc:a134526a9e561b38741398c32f76c91b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is a Building Block or not.  <a href="#a134526a9e561b38741398c32f76c91b8">More...</a><br /></td></tr>
<tr class="separator:a134526a9e561b38741398c32f76c91b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3672834c6627f73acc4219096301ada"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#aa3672834c6627f73acc4219096301ada">isIndexed</a> () const</td></tr>
<tr class="separator:aa3672834c6627f73acc4219096301ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f96f613f3813778606654fc57b9256b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8f96f613f3813778606654fc57b9256b">isInteger</a> () const</td></tr>
<tr class="memdesc:a8f96f613f3813778606654fc57b9256b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is an integer. Either an <a class="el" href="classInteger.html" title="Handle numbers in expr. ">Integer</a> object directly, or a <a class="el" href="classDouble.html" title="Handle numbers in expr. ">Double</a> that has an integer value.  <a href="#a8f96f613f3813778606654fc57b9256b">More...</a><br /></td></tr>
<tr class="separator:a8f96f613f3813778606654fc57b9256b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57c83bb6e902a6a15a361e3b23fc5df"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ac57c83bb6e902a6a15a361e3b23fc5df">getValued</a> () const</td></tr>
<tr class="memdesc:ac57c83bb6e902a6a15a361e3b23fc5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is valued, i.e. is a function of numbers and valued literals (a <a class="el" href="classVariable.html" title="Handle an object with a name and a value. ">Variable</a> or <a class="el" href="classConstant.html" title="Handle an object with a name and a value. ">Constant</a> is not valued by default).  <a href="#ac57c83bb6e902a6a15a361e3b23fc5df">More...</a><br /></td></tr>
<tr class="separator:ac57c83bb6e902a6a15a361e3b23fc5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba57b14ff887eea4ef9e031d69374cb"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#acba57b14ff887eea4ef9e031d69374cb">getValue</a> () const</td></tr>
<tr class="memdesc:acba57b14ff887eea4ef9e031d69374cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the expression, if it has one <b>explicitely</b>. In particular, it will work only on Numbers and valued Literals, not on functions.  <a href="#acba57b14ff887eea4ef9e031d69374cb">More...</a><br /></td></tr>
<tr class="separator:acba57b14ff887eea4ef9e031d69374cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa98d0f2d18bf275f6654a7fadd538e4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#afa98d0f2d18bf275f6654a7fadd538e4">getNum</a> () const</td></tr>
<tr class="separator:afa98d0f2d18bf275f6654a7fadd538e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a452f6609a695e82dbec0924fe6ad53"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a2a452f6609a695e82dbec0924fe6ad53">getDenom</a> () const</td></tr>
<tr class="separator:a2a452f6609a695e82dbec0924fe6ad53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9edafbda64687e956edd3710d52363"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a3f9edafbda64687e956edd3710d52363">getNArgs</a> (int axis=0) const</td></tr>
<tr class="memdesc:a3f9edafbda64687e956edd3710d52363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of arguments of the expression. If the expression is a building block (<a class="el" href="classAbstractBuildingBlock.html" title="Abstract class from which derive all building blocks of exprs, i.e. objects not function of further e...">AbstractBuildingBlock</a>), this function returns 0.  <a href="#a3f9edafbda64687e956edd3710d52363">More...</a><br /></td></tr>
<tr class="separator:a3f9edafbda64687e956edd3710d52363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035a4c5ffac26b9ee25d38b84030cd2e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a1fc3ae6bd5c6a80e9b81b27fc7b7a11a">iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a035a4c5ffac26b9ee25d38b84030cd2e">begin</a> ()</td></tr>
<tr class="separator:a035a4c5ffac26b9ee25d38b84030cd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad803d52cf561b46554883cc14251788f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a1fc3ae6bd5c6a80e9b81b27fc7b7a11a">iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ad803d52cf561b46554883cc14251788f">end</a> ()</td></tr>
<tr class="separator:ad803d52cf561b46554883cc14251788f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652cef4522482a03d616e8d39749a390"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#ac50bb217e67a9c51fa2b4322f56ec1a4">const_iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a652cef4522482a03d616e8d39749a390">begin</a> () const</td></tr>
<tr class="separator:a652cef4522482a03d616e8d39749a390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b8b381ee63c795f2ed54c36000b1ab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#ac50bb217e67a9c51fa2b4322f56ec1a4">const_iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a77b8b381ee63c795f2ed54c36000b1ab">end</a> () const</td></tr>
<tr class="separator:a77b8b381ee63c795f2ed54c36000b1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dab23c4d96c188bd24d38ad69eba20"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#aa3dab23c4d96c188bd24d38ad69eba20">getArgument</a> (int iArg=0) const</td></tr>
<tr class="separator:aa3dab23c4d96c188bd24d38ad69eba20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af92cbaad45ffb4e114b90038cc1495"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a4af92cbaad45ffb4e114b90038cc1495">getArgument</a> (const std::initializer_list&lt; int &gt; &amp;indices) const</td></tr>
<tr class="memdesc:a4af92cbaad45ffb4e114b90038cc1495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension.  <a href="#a4af92cbaad45ffb4e114b90038cc1495">More...</a><br /></td></tr>
<tr class="separator:a4af92cbaad45ffb4e114b90038cc1495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a803192766a3af8cc52747e6be2258b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8a803192766a3af8cc52747e6be2258b">getArgument</a> (const std::vector&lt; int &gt; &amp;indices) const</td></tr>
<tr class="memdesc:a8a803192766a3af8cc52747e6be2258b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension.  <a href="#a8a803192766a3af8cc52747e6be2258b">More...</a><br /></td></tr>
<tr class="separator:a8a803192766a3af8cc52747e6be2258b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7170bc22902a3964584ae8994a84b4"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a5a7170bc22902a3964584ae8994a84b4">getVectorArgument</a> () const</td></tr>
<tr class="memdesc:a5a7170bc22902a3964584ae8994a84b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get the entire std::vector of arguments of the expression.  <a href="#a5a7170bc22902a3964584ae8994a84b4">More...</a><br /></td></tr>
<tr class="separator:a5a7170bc22902a3964584ae8994a84b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d5fffe1213a826543171b4330af099"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#af2d5fffe1213a826543171b4330af099">getVariable</a> () const</td></tr>
<tr class="memdesc:af2d5fffe1213a826543171b4330af099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the variable that defines certain types of expressions.  <a href="#af2d5fffe1213a826543171b4330af099">More...</a><br /></td></tr>
<tr class="separator:af2d5fffe1213a826543171b4330af099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7f724371bd2b5c61d3615faef63beb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6d7f724371bd2b5c61d3615faef63beb">getOrder</a> () const</td></tr>
<tr class="memdesc:a6d7f724371bd2b5c61d3615faef63beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the order (integer) that defines certain types of expressions.  <a href="#a6d7f724371bd2b5c61d3615faef63beb">More...</a><br /></td></tr>
<tr class="separator:a6d7f724371bd2b5c61d3615faef63beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#acf82f9b2937375c7b1cf3dccb3df3312">isEmpty</a> () const</td></tr>
<tr class="memdesc:acf82f9b2937375c7b1cf3dccb3df3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells for a <a class="el" href="classDerivative.html" title="Handles the exponentiation of one Abstract wrt another. ">Derivative</a> or an Integral if the argument is empty i.e. if the object must apply on the next argument encountered on the right.  <a href="#acf82f9b2937375c7b1cf3dccb3df3312">More...</a><br /></td></tr>
<tr class="separator:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc79aa416f0937aa5c5c5ba07370a037"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#acc79aa416f0937aa5c5c5ba07370a037">getShape</a> () const</td></tr>
<tr class="memdesc:acc79aa416f0937aa5c5c5ba07370a037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the shape of the tensor in the form of a std::vector of integers.  <a href="#acc79aa416f0937aa5c5c5ba07370a037">More...</a><br /></td></tr>
<tr class="separator:acc79aa416f0937aa5c5c5ba07370a037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac702310492abaed2dfef1ee4d988d7c2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ac702310492abaed2dfef1ee4d988d7c2">getNIndices</a> () const</td></tr>
<tr class="separator:ac702310492abaed2dfef1ee4d988d7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d151ec6c57077235d5664cdc993827"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classIndex.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ad0d151ec6c57077235d5664cdc993827">getIndex</a> (int i=0) const</td></tr>
<tr class="separator:ad0d151ec6c57077235d5664cdc993827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd19eb640458e6e70ddaf35115aa2d2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classIndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6bd19eb640458e6e70ddaf35115aa2d2">getIndexStructure</a> () const</td></tr>
<tr class="separator:a6bd19eb640458e6e70ddaf35115aa2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7960d79b133f222a433de92b9562c7cc"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classIndicialParent.html">IndicialParent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a7960d79b133f222a433de92b9562c7cc">getParent</a> () const</td></tr>
<tr class="memdesc:a7960d79b133f222a433de92b9562c7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">For indicial expressions this function returns a pointer to the parent object of type <a class="el" href="classIndicialParent.html">IndicialParent</a> (not an expression).  <a href="#a7960d79b133f222a433de92b9562c7cc">More...</a><br /></td></tr>
<tr class="separator:a7960d79b133f222a433de92b9562c7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39a18f5d58508346e4c19d3c26a80d4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ae39a18f5d58508346e4c19d3c26a80d4">getNContractedPairs</a> () const</td></tr>
<tr class="memdesc:ae39a18f5d58508346e4c19d3c26a80d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of contracted pairs of indices <b>in an Indicial expression</b>.  <a href="#ae39a18f5d58508346e4c19d3c26a80d4">More...</a><br /></td></tr>
<tr class="separator:ae39a18f5d58508346e4c19d3c26a80d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bc1c2804eeb41a6ce2eaca0d741cf8"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a13bc1c2804eeb41a6ce2eaca0d741cf8">getPermutations</a> () const</td></tr>
<tr class="memdesc:a13bc1c2804eeb41a6ce2eaca0d741cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::vector of all possible permutations of an <b>Indicial</b> expression. The possible permutations are determined from the posible symmetries and anti-symmetries of the object.  <a href="#a13bc1c2804eeb41a6ce2eaca0d741cf8">More...</a><br /></td></tr>
<tr class="separator:a13bc1c2804eeb41a6ce2eaca0d741cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fa50ffd1b16b2ff0ad421a3a0760c1"><td class="memItemLeft" align="right" valign="top">virtual std::set&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a55fa50ffd1b16b2ff0ad421a3a0760c1">getContractedPair</a> () const</td></tr>
<tr class="separator:a55fa50ffd1b16b2ff0ad421a3a0760c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad305ee5e54d468c64c6b46658aa210e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ad305ee5e54d468c64c6b46658aa210e0">setName</a> (const std::string &amp;t_name)</td></tr>
<tr class="memdesc:ad305ee5e54d468c64c6b46658aa210e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the name of the abstract.  <a href="#ad305ee5e54d468c64c6b46658aa210e0">More...</a><br /></td></tr>
<tr class="separator:ad305ee5e54d468c64c6b46658aa210e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128daf984905d30e5c966492001c23b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a128daf984905d30e5c966492001c23b4">setCommutable</a> (bool t_commutable)</td></tr>
<tr class="memdesc:a128daf984905d30e5c966492001c23b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the abstract to commute or not.  <a href="#a128daf984905d30e5c966492001c23b4">More...</a><br /></td></tr>
<tr class="separator:a128daf984905d30e5c966492001c23b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf2751548904140aa7aa4a1e8e59346"><td class="memItemLeft" align="right" valign="top"><a id="afbf2751548904140aa7aa4a1e8e59346"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#afbf2751548904140aa7aa4a1e8e59346">setValue</a> (double t_value)</td></tr>
<tr class="memdesc:afbf2751548904140aa7aa4a1e8e59346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value if there is one (for Numerical and Literal valued). <br /></td></tr>
<tr class="separator:afbf2751548904140aa7aa4a1e8e59346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c8c199caec4d49c81b330954228b72"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a75c8c199caec4d49c81b330954228b72">setArgument</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, int iArg=0)</td></tr>
<tr class="memdesc:a75c8c199caec4d49c81b330954228b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the argument at position <b>iArg</b> (default=0).  <a href="#a75c8c199caec4d49c81b330954228b72">More...</a><br /></td></tr>
<tr class="separator:a75c8c199caec4d49c81b330954228b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f4a9411974d0b2f61a004c79139a64"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a61f4a9411974d0b2f61a004c79139a64">setArgument</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, const std::initializer_list&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:a61f4a9411974d0b2f61a004c79139a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions.  <a href="#a61f4a9411974d0b2f61a004c79139a64">More...</a><br /></td></tr>
<tr class="separator:a61f4a9411974d0b2f61a004c79139a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff36101861ab91916f2c617a15f7687"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#aaff36101861ab91916f2c617a15f7687">setArgument</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:aaff36101861ab91916f2c617a15f7687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions.  <a href="#aaff36101861ab91916f2c617a15f7687">More...</a><br /></td></tr>
<tr class="separator:aaff36101861ab91916f2c617a15f7687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76aaf6a94588273e3f92cf1980cf7ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ab76aaf6a94588273e3f92cf1980cf7ec">setVectorArgument</a> (const std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt; &amp;t_argument)</td></tr>
<tr class="memdesc:ab76aaf6a94588273e3f92cf1980cf7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the entire std::vector of argument.  <a href="#ab76aaf6a94588273e3f92cf1980cf7ec">More...</a><br /></td></tr>
<tr class="separator:ab76aaf6a94588273e3f92cf1980cf7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49620ec470e935ce2c770981e4f338dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a49620ec470e935ce2c770981e4f338dc">insert</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, bool side=0)</td></tr>
<tr class="memdesc:a49620ec470e935ce2c770981e4f338dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an expression in a sum or a product.  <a href="#a49620ec470e935ce2c770981e4f338dc">More...</a><br /></td></tr>
<tr class="separator:a49620ec470e935ce2c770981e4f338dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd2d23b77d3719cbe2db2f27c4ad9c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8bd2d23b77d3719cbe2db2f27c4ad9c9">setIndexStructure</a> (const std::vector&lt; <a class="el" href="classIndex.html">Index</a> &gt; &amp;t_index)</td></tr>
<tr class="memdesc:a8bd2d23b77d3719cbe2db2f27c4ad9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the index structure of the object, that must be an <b>Indicial</b> expression.  <a href="#a8bd2d23b77d3719cbe2db2f27c4ad9c9">More...</a><br /></td></tr>
<tr class="separator:a8bd2d23b77d3719cbe2db2f27c4ad9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac102096971b80a7510a4cb9da4ab6b03"><td class="memItemLeft" align="right" valign="top"><a id="ac102096971b80a7510a4cb9da4ab6b03"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ac102096971b80a7510a4cb9da4ab6b03">setFullySymmetric</a> ()</td></tr>
<tr class="memdesc:ac102096971b80a7510a4cb9da4ab6b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an <b>Indicial</b> object fully symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties of symmetry / antisymmetry and sets <b>fullySymmetric</b> to <b>True</b>. <br /></td></tr>
<tr class="separator:ac102096971b80a7510a4cb9da4ab6b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfef4ff87acec837e64ff73ccffdf369"><td class="memItemLeft" align="right" valign="top"><a id="acfef4ff87acec837e64ff73ccffdf369"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#acfef4ff87acec837e64ff73ccffdf369">setFullyAntiSymmetric</a> ()</td></tr>
<tr class="memdesc:acfef4ff87acec837e64ff73ccffdf369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an <b>Indicial</b> object fully anti-symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties * of symmetry / antisymmetry and sets <b>fullyAntiSymmetric</b> to <b>True</b>. <br /></td></tr>
<tr class="separator:acfef4ff87acec837e64ff73ccffdf369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7ae515cba43be48adbca7f6a8b6106"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a0e7ae515cba43be48adbca7f6a8b6106">addSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:a0e7ae515cba43be48adbca7f6a8b6106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a symmetry between the i1^{th} and the i2^{th} indices. If those indices are anti-symmetric, an error is thrown.  <a href="#a0e7ae515cba43be48adbca7f6a8b6106">More...</a><br /></td></tr>
<tr class="separator:a0e7ae515cba43be48adbca7f6a8b6106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fccaaa8870d764767ea291b351dc694"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a1fccaaa8870d764767ea291b351dc694">addAntiSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:a1fccaaa8870d764767ea291b351dc694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an anti-symmetry between the i1^{th} and the i2^{th} indices. If those indices are symmetric, an error is thrown.  <a href="#a1fccaaa8870d764767ea291b351dc694">More...</a><br /></td></tr>
<tr class="separator:a1fccaaa8870d764767ea291b351dc694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f5a37ad523ec663a61d07def420820"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ae9f5a37ad523ec663a61d07def420820">permut</a> (int i1, int i2)</td></tr>
<tr class="memdesc:ae9f5a37ad523ec663a61d07def420820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to permut indices at place <b>i1</b> and <b>i2</b>. If those two indices have a symmetry property, indices are swaped and the symmetry is returned. Else the fnuction does nothing and returns 0.  <a href="#ae9f5a37ad523ec663a61d07def420820">More...</a><br /></td></tr>
<tr class="separator:ae9f5a37ad523ec663a61d07def420820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0cb1177644e0851aa6721c5be5880a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6f0cb1177644e0851aa6721c5be5880a">contractIndices</a> (int axis1, int axis2)</td></tr>
<tr class="memdesc:a6f0cb1177644e0851aa6721c5be5880a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contracts the indices at position <b>axis1</b> and <b>axis2</b>. The indices then become dummy indices.  <a href="#a6f0cb1177644e0851aa6721c5be5880a">More...</a><br /></td></tr>
<tr class="separator:a6f0cb1177644e0851aa6721c5be5880a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839372b7667ea0a28a9e3b72112366ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a839372b7667ea0a28a9e3b72112366ff">getNumericalFactor</a> () const</td></tr>
<tr class="memdesc:a839372b7667ea0a28a9e3b72112366ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the numerical factor of the expression, i.e. returns <b>C</b> if the expression if of the form <b>C*x</b> (<b>x</b> having a numerical factor equal to 1), and return 1 else.  <a href="#a839372b7667ea0a28a9e3b72112366ff">More...</a><br /></td></tr>
<tr class="separator:a839372b7667ea0a28a9e3b72112366ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594a570f0139f92f284f31e91c0c6dd8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a594a570f0139f92f284f31e91c0c6dd8">getNFactor</a> () const</td></tr>
<tr class="separator:a594a570f0139f92f284f31e91c0c6dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdf2d5371e8c8ead87ef2b5d6fe43c0"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a5fdf2d5371e8c8ead87ef2b5d6fe43c0">getFactors</a> () const</td></tr>
<tr class="memdesc:a5fdf2d5371e8c8ead87ef2b5d6fe43c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get a std::vector of all terms than could factor the expression.  <a href="#a5fdf2d5371e8c8ead87ef2b5d6fe43c0">More...</a><br /></td></tr>
<tr class="separator:a5fdf2d5371e8c8ead87ef2b5d6fe43c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eab0d3915f47bc492ecaaf508afca4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ad4eab0d3915f47bc492ecaaf508afca4">getTerm</a> ()</td></tr>
<tr class="memdesc:ad4eab0d3915f47bc492ecaaf508afca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the same expression as *this but amputated of its numerical factor. Example: (4*cos(x) -&gt; cos(x)).  <a href="#ad4eab0d3915f47bc492ecaaf508afca4">More...</a><br /></td></tr>
<tr class="separator:ad4eab0d3915f47bc492ecaaf508afca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade7a4e3912241b00acd22b78d419fae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#aade7a4e3912241b00acd22b78d419fae">checkIndexStructure</a> (const std::vector&lt; <a class="el" href="classIndex.html">Index</a> &gt; &amp;t_index) const</td></tr>
<tr class="memdesc:aade7a4e3912241b00acd22b78d419fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure.  <a href="#aade7a4e3912241b00acd22b78d419fae">More...</a><br /></td></tr>
<tr class="separator:aade7a4e3912241b00acd22b78d419fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e32ab95b1ed1e2cca89de5f83cce1b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a23e32ab95b1ed1e2cca89de5f83cce1b">checkIndexStructure</a> (const std::initializer_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &amp;index) const</td></tr>
<tr class="memdesc:a23e32ab95b1ed1e2cca89de5f83cce1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure.  <a href="#a23e32ab95b1ed1e2cca89de5f83cce1b">More...</a><br /></td></tr>
<tr class="separator:a23e32ab95b1ed1e2cca89de5f83cce1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950163457cbd6cef954422a1821eda7a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a950163457cbd6cef954422a1821eda7a">getParity</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;t_variable) const</td></tr>
<tr class="memdesc:a950163457cbd6cef954422a1821eda7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parity property of the expression with respect to <b>t_variable</b>.  <a href="#a950163457cbd6cef954422a1821eda7a">More...</a><br /></td></tr>
<tr class="separator:a950163457cbd6cef954422a1821eda7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c858cbdb891b94ed1d2166f3b8392d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a50c858cbdb891b94ed1d2166f3b8392d">askTerm</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, bool exact=false) const</td></tr>
<tr class="memdesc:a50c858cbdb891b94ed1d2166f3b8392d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <b>expr</b> can factor <b>*this</b>.  <a href="#a50c858cbdb891b94ed1d2166f3b8392d">More...</a><br /></td></tr>
<tr class="separator:a50c858cbdb891b94ed1d2166f3b8392d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6750df27f71d1c2e35d7a7f75c16d5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6e6750df27f71d1c2e35d7a7f75c16d5">dependsOn</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a6e6750df27f71d1c2e35d7a7f75c16d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check recursively if <b>expr</b> is present in the expression.  <a href="#a6e6750df27f71d1c2e35d7a7f75c16d5">More...</a><br /></td></tr>
<tr class="separator:a6e6750df27f71d1c2e35d7a7f75c16d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fb27a847c4aceb353cce8183df51be"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#af5fb27a847c4aceb353cce8183df51be">isPolynomial</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:af5fb27a847c4aceb353cce8183df51be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the expression is a mononomial term in <b>expr</b>, i.e. a term of the form C*expr^n with C independent of expr, n integer.  <a href="#af5fb27a847c4aceb353cce8183df51be">More...</a><br /></td></tr>
<tr class="separator:af5fb27a847c4aceb353cce8183df51be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e8162a13d141bbc3fe41b37f7c98e2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#af5e8162a13d141bbc3fe41b37f7c98e2">matchShape</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, bool exact=false) const</td></tr>
<tr class="memdesc:af5e8162a13d141bbc3fe41b37f7c98e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case of a vectorial-type expression, this function checks if the shape of expr matches itself.  <a href="#af5e8162a13d141bbc3fe41b37f7c98e2">More...</a><br /></td></tr>
<tr class="separator:af5e8162a13d141bbc3fe41b37f7c98e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd473f3a4f62f338f5b0ee3b10453f39"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#abd473f3a4f62f338f5b0ee3b10453f39">evaluateScalar</a> () const</td></tr>
<tr class="memdesc:abd473f3a4f62f338f5b0ee3b10453f39"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the value of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#abd473f3a4f62f338f5b0ee3b10453f39">More...</a><br /></td></tr>
<tr class="separator:abd473f3a4f62f338f5b0ee3b10453f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f313e9690045d548592ce82f9c365c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a02f313e9690045d548592ce82f9c365c">evaluate</a> ()=0</td></tr>
<tr class="memdesc:a02f313e9690045d548592ce82f9c365c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a02f313e9690045d548592ce82f9c365c">More...</a><br /></td></tr>
<tr class="separator:a02f313e9690045d548592ce82f9c365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0051bf527eff054316fb14511d10e155"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a0051bf527eff054316fb14511d10e155">derive</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a0051bf527eff054316fb14511d10e155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivative of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt another.  <a href="#a0051bf527eff054316fb14511d10e155">More...</a><br /></td></tr>
<tr class="separator:a0051bf527eff054316fb14511d10e155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47214a866e4c0b5f9f0dcefc5aa1da39"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a47214a866e4c0b5f9f0dcefc5aa1da39">factor</a> (bool full=false)</td></tr>
<tr class="memdesc:a47214a866e4c0b5f9f0dcefc5aa1da39"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Factors</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a47214a866e4c0b5f9f0dcefc5aa1da39">More...</a><br /></td></tr>
<tr class="separator:a47214a866e4c0b5f9f0dcefc5aa1da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbe086f2cbc7fcdd072b8a29fe2abe6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a4fbe086f2cbc7fcdd072b8a29fe2abe6">factor</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;factor, bool full=false)</td></tr>
<tr class="memdesc:a4fbe086f2cbc7fcdd072b8a29fe2abe6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Factors</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt a <b>particular</b> <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a4fbe086f2cbc7fcdd072b8a29fe2abe6">More...</a><br /></td></tr>
<tr class="separator:a4fbe086f2cbc7fcdd072b8a29fe2abe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ac62534de5f3fd86899a9c2edb8f43"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a50ac62534de5f3fd86899a9c2edb8f43">suppressTerm</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a50ac62534de5f3fd86899a9c2edb8f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a factor from an expr, that must have been determined before.  <a href="#a50ac62534de5f3fd86899a9c2edb8f43">More...</a><br /></td></tr>
<tr class="separator:a50ac62534de5f3fd86899a9c2edb8f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cffcbbde45509935dd3179383dfcd8c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a7cffcbbde45509935dd3179383dfcd8c">develop</a> (bool full=false)</td></tr>
<tr class="memdesc:a7cffcbbde45509935dd3179383dfcd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Develops</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a7cffcbbde45509935dd3179383dfcd8c">More...</a><br /></td></tr>
<tr class="separator:a7cffcbbde45509935dd3179383dfcd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3cdd2b7bf7c6a6df773b68c9af5153"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#afc3cdd2b7bf7c6a6df773b68c9af5153">getRealPart</a> ()</td></tr>
<tr class="memdesc:afc3cdd2b7bf7c6a6df773b68c9af5153"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>real part</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#afc3cdd2b7bf7c6a6df773b68c9af5153">More...</a><br /></td></tr>
<tr class="separator:afc3cdd2b7bf7c6a6df773b68c9af5153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc37867d634b3538379f6256d6c7e29"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6fc37867d634b3538379f6256d6c7e29">getImaginaryPart</a> () const</td></tr>
<tr class="memdesc:a6fc37867d634b3538379f6256d6c7e29"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>imaginary part</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#a6fc37867d634b3538379f6256d6c7e29">More...</a><br /></td></tr>
<tr class="separator:a6fc37867d634b3538379f6256d6c7e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff23826dac23c21b39a9d4ef59d50c76"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#aff23826dac23c21b39a9d4ef59d50c76">getComplexModulus</a> ()</td></tr>
<tr class="memdesc:aff23826dac23c21b39a9d4ef59d50c76"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>modulus in the complex plane</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#aff23826dac23c21b39a9d4ef59d50c76">More...</a><br /></td></tr>
<tr class="separator:aff23826dac23c21b39a9d4ef59d50c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a594594ebcc69a4945ab6890e203deb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a0a594594ebcc69a4945ab6890e203deb">getComplexArgument</a> ()</td></tr>
<tr class="memdesc:a0a594594ebcc69a4945ab6890e203deb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>argument in the complex plane</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#a0a594594ebcc69a4945ab6890e203deb">More...</a><br /></td></tr>
<tr class="separator:a0a594594ebcc69a4945ab6890e203deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3317c522a29f999c5631d7e3b6431372"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a3317c522a29f999c5631d7e3b6431372">getComplexConjugate</a> ()</td></tr>
<tr class="memdesc:a3317c522a29f999c5631d7e3b6431372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the complex conjugate of the expression.  <a href="#a3317c522a29f999c5631d7e3b6431372">More...</a><br /></td></tr>
<tr class="separator:a3317c522a29f999c5631d7e3b6431372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fa7ef6049a03bb02382ee6f6cde2f9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a69fa7ef6049a03bb02382ee6f6cde2f9">getPolynomialTerm</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;t_variable, int order)</td></tr>
<tr class="memdesc:a69fa7ef6049a03bb02382ee6f6cde2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the polynomial term corresponding to <b>*this</b> with the variable <b>t_variable</b> at order <b>order</b>. In particular, this function assumes that the checks have already been made with the function <a class="el" href="classAbstract.html#af5fb27a847c4aceb353cce8183df51be" title="Determines if the expression is a mononomial term in expr, i.e. a term of the form C*expr^n with C in...">isPolynomial()</a>.  <a href="#a69fa7ef6049a03bb02382ee6f6cde2f9">More...</a><br /></td></tr>
<tr class="separator:a69fa7ef6049a03bb02382ee6f6cde2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6979d84d75c4d4057d961ad84043dbd9"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6979d84d75c4d4057d961ad84043dbd9">getAlternateForms</a> () const</td></tr>
<tr class="memdesc:a6979d84d75c4d4057d961ad84043dbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns all possible alternate forms of the expression in terms of simplifications. For example 1-sin^2(x) is one of the alternate forms of cos^2(x).  <a href="#a6979d84d75c4d4057d961ad84043dbd9">More...</a><br /></td></tr>
<tr class="separator:a6979d84d75c4d4057d961ad84043dbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf1d8170b6d7ec53b265462f8e1a552"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a0cf1d8170b6d7ec53b265462f8e1a552">addition_own</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a0cf1d8170b6d7ec53b265462f8e1a552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special addition for Numerical- and Vectorial-types.  <a href="#a0cf1d8170b6d7ec53b265462f8e1a552">More...</a><br /></td></tr>
<tr class="separator:a0cf1d8170b6d7ec53b265462f8e1a552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc5594d9ea621809a36f8f71cfbcc8a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a4bc5594d9ea621809a36f8f71cfbcc8a">multiplication_own</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a4bc5594d9ea621809a36f8f71cfbcc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special multiplication for Numerical- and Vectorial-types.  <a href="#a4bc5594d9ea621809a36f8f71cfbcc8a">More...</a><br /></td></tr>
<tr class="separator:a4bc5594d9ea621809a36f8f71cfbcc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab218b3bc5d3930191ded81b2d689ab2d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ab218b3bc5d3930191ded81b2d689ab2d">division_own</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:ab218b3bc5d3930191ded81b2d689ab2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special division for Numerical- and Polynomial-types. For polynomial, the euclidean division of two polynomials is implemented.  <a href="#ab218b3bc5d3930191ded81b2d689ab2d">More...</a><br /></td></tr>
<tr class="separator:ab218b3bc5d3930191ded81b2d689ab2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc999066a217b4fd767dadb5114d3698"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#abc999066a217b4fd767dadb5114d3698">exponentiation_own</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:abc999066a217b4fd767dadb5114d3698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special exponentiation for Numerical- and Vectorial-types.  <a href="#abc999066a217b4fd767dadb5114d3698">More...</a><br /></td></tr>
<tr class="separator:abc999066a217b4fd767dadb5114d3698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e5fc56dcab6f16259d0e6925aa51c0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ab5e5fc56dcab6f16259d0e6925aa51c0">getRegularExpression</a> () const</td></tr>
<tr class="memdesc:ab5e5fc56dcab6f16259d0e6925aa51c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a regular expression from the polynomial, that is a sum where the different powers of the variable appear explicitely.  <a href="#ab5e5fc56dcab6f16259d0e6925aa51c0">More...</a><br /></td></tr>
<tr class="separator:ab5e5fc56dcab6f16259d0e6925aa51c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250b633a570e586433cea97c05fcc5fe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a250b633a570e586433cea97c05fcc5fe">tensor_dot</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a250b633a570e586433cea97c05fcc5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor_dot of two <b>Vectorial</b> expressions.  <a href="#a250b633a570e586433cea97c05fcc5fe">More...</a><br /></td></tr>
<tr class="separator:a250b633a570e586433cea97c05fcc5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac2674de22496c96d6229eae2968fdd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a7ac2674de22496c96d6229eae2968fdd">dot</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a7ac2674de22496c96d6229eae2968fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of two <b>Vectorial</b> expressions.  <a href="#a7ac2674de22496c96d6229eae2968fdd">More...</a><br /></td></tr>
<tr class="separator:a7ac2674de22496c96d6229eae2968fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba9f54b32db597435e94cf8645175e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8ba9f54b32db597435e94cf8645175e6">getSum</a> () const</td></tr>
<tr class="memdesc:a8ba9f54b32db597435e94cf8645175e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the sum of all elements in the <b>Vectorial</b> object.  <a href="#a8ba9f54b32db597435e94cf8645175e6">More...</a><br /></td></tr>
<tr class="separator:a8ba9f54b32db597435e94cf8645175e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97407d5f8eb14ece9c7335d56930640c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a97407d5f8eb14ece9c7335d56930640c">getProduct</a> () const</td></tr>
<tr class="memdesc:a97407d5f8eb14ece9c7335d56930640c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the product of all elements in the <b>Vectorial</b> object.  <a href="#a97407d5f8eb14ece9c7335d56930640c">More...</a><br /></td></tr>
<tr class="separator:a97407d5f8eb14ece9c7335d56930640c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3920c1dff045e546ccc0286c2c2677e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a3920c1dff045e546ccc0286c2c2677e8">getVectorialModulus</a> () const</td></tr>
<tr class="memdesc:a3920c1dff045e546ccc0286c2c2677e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Vectorial modulus of the <b>Vectorial</b> object, that is defined here as the squared root of the sum of element squared. Example: {A_{11}^2+A_{12}^2+}.  <a href="#a3920c1dff045e546ccc0286c2c2677e8">More...</a><br /></td></tr>
<tr class="separator:a3920c1dff045e546ccc0286c2c2677e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57bb5ebdd5cd06237267a4c26b61590"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ab57bb5ebdd5cd06237267a4c26b61590">getSubVectorial</a> (int iExcept) const</td></tr>
<tr class="memdesc:ab57bb5ebdd5cd06237267a4c26b61590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element.  <a href="#ab57bb5ebdd5cd06237267a4c26b61590">More...</a><br /></td></tr>
<tr class="separator:ab57bb5ebdd5cd06237267a4c26b61590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409da64180d33314dc802014dc6d963f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a409da64180d33314dc802014dc6d963f">getSubVectorial</a> (int iExcept, int jExcept) const</td></tr>
<tr class="memdesc:a409da64180d33314dc802014dc6d963f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the [iExcept^{th},jExcept^{th}] element (useful for matrices).  <a href="#a409da64180d33314dc802014dc6d963f">More...</a><br /></td></tr>
<tr class="separator:a409da64180d33314dc802014dc6d963f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77756abf1144b00e44eafabd582740fe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a77756abf1144b00e44eafabd582740fe">getSubVectorial</a> (const std::vector&lt; int &gt; &amp;exceptions) const</td></tr>
<tr class="memdesc:a77756abf1144b00e44eafabd582740fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element.  <a href="#a77756abf1144b00e44eafabd582740fe">More...</a><br /></td></tr>
<tr class="separator:a77756abf1144b00e44eafabd582740fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aebaa743c24d2faf6b9f2576c21a1df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a9aebaa743c24d2faf6b9f2576c21a1df">determinant</a> () const</td></tr>
<tr class="memdesc:a9aebaa743c24d2faf6b9f2576c21a1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the object if it corresponds to a square matrix (or a scalar), 0 else.  <a href="#a9aebaa743c24d2faf6b9f2576c21a1df">More...</a><br /></td></tr>
<tr class="separator:a9aebaa743c24d2faf6b9f2576c21a1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ebeb9355bb8491aeb909094ef1a946"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a31ebeb9355bb8491aeb909094ef1a946">trace</a> () const</td></tr>
<tr class="separator:a31ebeb9355bb8491aeb909094ef1a946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d7558a06855e805ab2b347c89fbab4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a12d7558a06855e805ab2b347c89fbab4">trace</a> (int axis1, int axis2) const</td></tr>
<tr class="memdesc:a12d7558a06855e805ab2b347c89fbab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the trace over the axis <b>axis1</b> and <b>axis2</b> of a tensor. <b>axis1</b> and <b>axis2</b> can be the same, in which case the trace just corresponds to the sum over this particular axis.  <a href="#a12d7558a06855e805ab2b347c89fbab4">More...</a><br /></td></tr>
<tr class="separator:a12d7558a06855e805ab2b347c89fbab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c28051b0366bafc6dcb0704d765fe9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a23c28051b0366bafc6dcb0704d765fe9">transpose</a> () const</td></tr>
<tr class="memdesc:a23c28051b0366bafc6dcb0704d765fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the transpose of a 2D matrix.  <a href="#a23c28051b0366bafc6dcb0704d765fe9">More...</a><br /></td></tr>
<tr class="separator:a23c28051b0366bafc6dcb0704d765fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8269986297fc4b551de89d6d3900ca36"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8269986297fc4b551de89d6d3900ca36">symmetrise</a> () const</td></tr>
<tr class="memdesc:a8269986297fc4b551de89d6d3900ca36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the symmetrization of a 2D matrix.  <a href="#a8269986297fc4b551de89d6d3900ca36">More...</a><br /></td></tr>
<tr class="separator:a8269986297fc4b551de89d6d3900ca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457f5c71cab762a8a8565479a732d7bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a457f5c71cab762a8a8565479a732d7bd">antisymmetrise</a> () const</td></tr>
<tr class="memdesc:a457f5c71cab762a8a8565479a732d7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the anti-symmetrization of a 2D matrix.  <a href="#a457f5c71cab762a8a8565479a732d7bd">More...</a><br /></td></tr>
<tr class="separator:a457f5c71cab762a8a8565479a732d7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bec3a80614b4fa4352577eb0528b79"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#aa7bec3a80614b4fa4352577eb0528b79">inverseMatrix</a> () const</td></tr>
<tr class="memdesc:aa7bec3a80614b4fa4352577eb0528b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the inverse of a 2D square matrix. The applied method is: A^{-1} = 1/det(A)*Com(A)^T.  <a href="#aa7bec3a80614b4fa4352577eb0528b79">More...</a><br /></td></tr>
<tr class="separator:aa7bec3a80614b4fa4352577eb0528b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e27d5fe7cf8a4db9e837a024b8e73e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a45e27d5fe7cf8a4db9e837a024b8e73e">operator=</a> (double t_value)</td></tr>
<tr class="memdesc:a45e27d5fe7cf8a4db9e837a024b8e73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the <a class="el" href="classAbstract.html#afbf2751548904140aa7aa4a1e8e59346" title="Sets the value if there is one (for Numerical and Literal valued). ">setValue()</a> function.  <a href="#a45e27d5fe7cf8a4db9e837a024b8e73e">More...</a><br /></td></tr>
<tr class="separator:a45e27d5fe7cf8a4db9e837a024b8e73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9687663de691e5ce2750370e0c6ab295"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a9687663de691e5ce2750370e0c6ab295">operator==</a> (int t_value) const</td></tr>
<tr class="separator:a9687663de691e5ce2750370e0c6ab295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e08758ab4a9422c56b18af734f9ed18"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8e08758ab4a9422c56b18af734f9ed18">operator==</a> (double t_value) const</td></tr>
<tr class="separator:a8e08758ab4a9422c56b18af734f9ed18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e51647ab1a6ab6c1151d3b1fe00575c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a4e51647ab1a6ab6c1151d3b1fe00575c">operator!=</a> (int t_value) const</td></tr>
<tr class="separator:a4e51647ab1a6ab6c1151d3b1fe00575c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5d7caab7b39ed1a425456e09fe10d8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a2d5d7caab7b39ed1a425456e09fe10d8">operator!=</a> (double t_value) const</td></tr>
<tr class="separator:a2d5d7caab7b39ed1a425456e09fe10d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6659bcfd9c94a8b2605027ca77d2f8fe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6659bcfd9c94a8b2605027ca77d2f8fe">operator==</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const =0</td></tr>
<tr class="memdesc:a6659bcfd9c94a8b2605027ca77d2f8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Compares</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another.  <a href="#a6659bcfd9c94a8b2605027ca77d2f8fe">More...</a><br /></td></tr>
<tr class="separator:a6659bcfd9c94a8b2605027ca77d2f8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd82f421ad221566224e1ddf22978b04"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#abd82f421ad221566224e1ddf22978b04">operator!=</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:abd82f421ad221566224e1ddf22978b04"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Compares</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another.  <a href="#abd82f421ad221566224e1ddf22978b04">More...</a><br /></td></tr>
<tr class="separator:abd82f421ad221566224e1ddf22978b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdf1c2cd531cc0385c5879a83ee15f6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a0cdf1c2cd531cc0385c5879a83ee15f6">operator[]</a> (int iArg)</td></tr>
<tr class="memdesc:a0cdf1c2cd531cc0385c5879a83ee15f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator for multi-argument expressions, equivalent to the function <a class="el" href="classAbstract.html#a75c8c199caec4d49c81b330954228b72" title="Sets the argument at position iArg (default=0). ">setArgument()</a>.  <a href="#a0cdf1c2cd531cc0385c5879a83ee15f6">More...</a><br /></td></tr>
<tr class="separator:a0cdf1c2cd531cc0385c5879a83ee15f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cfb786cf54b23696ccdb0a9dd9d6ad"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a13cfb786cf54b23696ccdb0a9dd9d6ad">operator|=</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a13cfb786cf54b23696ccdb0a9dd9d6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="#a13cfb786cf54b23696ccdb0a9dd9d6ad">More...</a><br /></td></tr>
<tr class="separator:a13cfb786cf54b23696ccdb0a9dd9d6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c15e5e29f3e15ade703b1135efd20f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ad3c15e5e29f3e15ade703b1135efd20f">operator &amp;=</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:ad3c15e5e29f3e15ade703b1135efd20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="#ad3c15e5e29f3e15ade703b1135efd20f">More...</a><br /></td></tr>
<tr class="separator:ad3c15e5e29f3e15ade703b1135efd20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26068fd48ccc64453283e32c552f9e5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#af26068fd48ccc64453283e32c552f9e5">operator&gt;</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const =0</td></tr>
<tr class="memdesc:af26068fd48ccc64453283e32c552f9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="#af26068fd48ccc64453283e32c552f9e5">More...</a><br /></td></tr>
<tr class="separator:af26068fd48ccc64453283e32c552f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc57fa894a78c5daebc8bc3ef113740f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#afc57fa894a78c5daebc8bc3ef113740f">operator&lt;</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const =0</td></tr>
<tr class="memdesc:afc57fa894a78c5daebc8bc3ef113740f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="#afc57fa894a78c5daebc8bc3ef113740f">More...</a><br /></td></tr>
<tr class="separator:afc57fa894a78c5daebc8bc3ef113740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94e9a1081c5b78f63fa05ea6e379d6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#af94e9a1081c5b78f63fa05ea6e379d6f">operator&gt;=</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:af94e9a1081c5b78f63fa05ea6e379d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="#af94e9a1081c5b78f63fa05ea6e379d6f">More...</a><br /></td></tr>
<tr class="separator:af94e9a1081c5b78f63fa05ea6e379d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba6b588c907bb15f8daa152655e58e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a3ba6b588c907bb15f8daa152655e58e5">operator&lt;=</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a3ba6b588c907bb15f8daa152655e58e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="#a3ba6b588c907bb15f8daa152655e58e5">More...</a><br /></td></tr>
<tr class="separator:a3ba6b588c907bb15f8daa152655e58e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9b45b3e13bd9167aab02e17e08916231"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a9b45b3e13bd9167aab02e17e08916231">name</a></td></tr>
<tr class="separator:a9b45b3e13bd9167aab02e17e08916231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b736117ed72bc3d8bc6813c97ca850"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a98b736117ed72bc3d8bc6813c97ca850">commutable</a></td></tr>
<tr class="separator:a98b736117ed72bc3d8bc6813c97ca850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5526f40b4ddcf23b599388283b318a13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a5526f40b4ddcf23b599388283b318a13">indexed</a></td></tr>
<tr class="separator:a5526f40b4ddcf23b599388283b318a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><b>Root</b> class of the inheritance tree of abstracts. </p>
<p>Contains all functions that derived class needs. In particular all documented functions of the class <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> are <b>specialized</b> in all the <b>derived</b> <b>classes</b>. </p><dl class="section note"><dt>Note</dt><dd>Some functions are not documented here because not every derived class use them. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acc6e3314f7cec8a356e1ee6a9dde1d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6e3314f7cec8a356e1ee6a9dde1d18">&#9670;&nbsp;</a></span>Abstract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAbstract.html">Abstract</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Constructor. </p>
<p>Initializes name empty and commutable to <b>True</b>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1fccaaa8870d764767ea291b351dc694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fccaaa8870d764767ea291b351dc694">&#9670;&nbsp;</a></span>addAntiSymmetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addAntiSymmetry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an anti-symmetry between the i1^{th} and the i2^{th} indices. If those indices are symmetric, an error is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i1</td><td>Position of the first index. </td></tr>
    <tr><td class="paramname">i2</td><td>Position of the second index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cf1d8170b6d7ec53b265462f8e1a552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf1d8170b6d7ec53b265462f8e1a552">&#9670;&nbsp;</a></span>addition_own()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> addition_own </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains implementation of special addition for Numerical- and Vectorial-types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Right operrand of the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two operands. </dd></dl>

<p>Reimplemented in <a class="el" href="classCFraction.html#a86e9b3d2f9ab4d020ca63082e78978b4">CFraction</a>, <a class="el" href="classDouble.html#a86e9b3d2f9ab4d020ca63082e78978b4">Double</a>, <a class="el" href="classPolynomial.html#a86e9b3d2f9ab4d020ca63082e78978b4">Polynomial</a>, <a class="el" href="classInteger.html#a86e9b3d2f9ab4d020ca63082e78978b4">Integer</a>, and <a class="el" href="classAbstractVectorial.html#a86e9b3d2f9ab4d020ca63082e78978b4">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a0e7ae515cba43be48adbca7f6a8b6106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7ae515cba43be48adbca7f6a8b6106">&#9670;&nbsp;</a></span>addSymmetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addSymmetry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a symmetry between the i1^{th} and the i2^{th} indices. If those indices are anti-symmetric, an error is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i1</td><td>Position of the first index. </td></tr>
    <tr><td class="paramname">i2</td><td>Position of the second index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a457f5c71cab762a8a8565479a732d7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457f5c71cab762a8a8565479a732d7bd">&#9670;&nbsp;</a></span>antisymmetrise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> antisymmetrise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the anti-symmetrization of a 2D matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>1/2*(A - A^T) for a matrix (2D) A. </dd></dl>

<p>Reimplemented in <a class="el" href="classMatrix.html#a06407aec82eb2970dab13eaec0896cf1">Matrix</a>.</p>

</div>
</div>
<a id="a50c858cbdb891b94ed1d2166f3b8392d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c858cbdb891b94ed1d2166f3b8392d">&#9670;&nbsp;</a></span>askTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool askTerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <b>expr</b> can factor <b>*this</b>. </p>
<p>In almost every case this corresponds just to the comparison ** *this == expr**. For <a class="el" href="classTimes.html" title="Handles a product, function of multiple arguments. ">Times</a>, <a class="el" href="classPow.html" title="Handles the exponentiation of one Abstract wrt another. ">Pow</a>, <a class="el" href="classFraction.html" title="Handles a fraction of 2 arguments. ">Fraction</a> types (all that are multiplicative) we must check if the factor hides in a product. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Factor to search in the expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>expr</b> is a possible factor. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classPow.html#a80cd2077e413cdb05d2e9142ea5c0095">Pow</a>, <a class="el" href="classFraction.html#a80cd2077e413cdb05d2e9142ea5c0095">Fraction</a>, and <a class="el" href="classTimes.html#a80cd2077e413cdb05d2e9142ea5c0095">Times</a>.</p>

</div>
</div>
<a id="a035a4c5ffac26b9ee25d38b84030cd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035a4c5ffac26b9ee25d38b84030cd2e">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a1fc3ae6bd5c6a80e9b81b27fc7b7a11a">iter</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Expr&gt;::iterator at the beginning of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#ad7464cab53ca461aa7a8892b0dae42ad">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a652cef4522482a03d616e8d39749a390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652cef4522482a03d616e8d39749a390">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#ac50bb217e67a9c51fa2b4322f56ec1a4">const_iter</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Expr&gt;::iterator at the beginning of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#a7a6bf18a6497121de6a24684f727a88d">AbstractVectorial</a>.</p>

</div>
</div>
<a id="aade7a4e3912241b00acd22b78d419fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade7a4e3912241b00acd22b78d419fae">&#9670;&nbsp;</a></span>checkIndexStructure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool checkIndexStructure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>t_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_index</td><td>A std::vector of <a class="el" href="classIndex.html">Index</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two structures match. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classITensor.html#a155ca331bb04527f36efc5ac501d67cd">ITensor</a>.</p>

</div>
</div>
<a id="a23e32ab95b1ed1e2cca89de5f83cce1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e32ab95b1ed1e2cca89de5f83cce1b">&#9670;&nbsp;</a></span>checkIndexStructure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool checkIndexStructure </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_index</td><td>A std::initializer_list of <a class="el" href="classIndex.html">Index</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two structures match. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classITensor.html#a702f371ae73c0eab9810d5428272c257">ITensor</a>.</p>

</div>
</div>
<a id="a6f0cb1177644e0851aa6721c5be5880a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0cb1177644e0851aa6721c5be5880a">&#9670;&nbsp;</a></span>contractIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void contractIndices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contracts the indices at position <b>axis1</b> and <b>axis2</b>. The indices then become dummy indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis1</td><td>Position of the first index to contract. </td></tr>
    <tr><td class="paramname">axis2</td><td>Position of the second index to contract. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classITensor.html#a8b921f94de91262698dca76542876cd0">ITensor</a>.</p>

</div>
</div>
<a id="a6e6750df27f71d1c2e35d7a7f75c16d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6750df27f71d1c2e35d7a7f75c16d5">&#9670;&nbsp;</a></span>dependsOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dependsOn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check recursively if <b>expr</b> is present in the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>expr</b> is found. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classVariable.html#a8f3e79303a8a9fb9e0c12814b5d39cd1">Variable</a>, <a class="el" href="classAbstractMultiFunc.html#a8f3e79303a8a9fb9e0c12814b5d39cd1">AbstractMultiFunc</a>, <a class="el" href="classAbstractDuoFunc.html#a8f3e79303a8a9fb9e0c12814b5d39cd1">AbstractDuoFunc</a>, and <a class="el" href="classAbstractFunc.html#a8f3e79303a8a9fb9e0c12814b5d39cd1">AbstractFunc</a>.</p>

</div>
</div>
<a id="a0051bf527eff054316fb14511d10e155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0051bf527eff054316fb14511d10e155">&#9670;&nbsp;</a></span>derive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> derive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the derivative of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt another. </p>
<p>It is possible to derive wrt any complicated expr. In this case however, the calculation is <b>not</b> <b>always</b> <b>mathematically</b> <b>correct</b>. The program just searches for equal <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> or <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with the same name. In particular dx/d(exp(x))=0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression wrt which we derive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative. </dd></dl>

<p>Reimplemented in <a class="el" href="classFactorial.html#a734e27903a01ed65bac0ed55cde728bc">Factorial</a>, <a class="el" href="classATanh.html#a734e27903a01ed65bac0ed55cde728bc">ATanh</a>, <a class="el" href="classASinh.html#a734e27903a01ed65bac0ed55cde728bc">ASinh</a>, <a class="el" href="classACosh.html#a734e27903a01ed65bac0ed55cde728bc">ACosh</a>, <a class="el" href="classTanh.html#a734e27903a01ed65bac0ed55cde728bc">Tanh</a>, <a class="el" href="classSinh.html#a734e27903a01ed65bac0ed55cde728bc">Sinh</a>, <a class="el" href="classImaginary.html#a734e27903a01ed65bac0ed55cde728bc">Imaginary</a>, <a class="el" href="classCosh.html#a734e27903a01ed65bac0ed55cde728bc">Cosh</a>, <a class="el" href="classCFactorial.html#a734e27903a01ed65bac0ed55cde728bc">CFactorial</a>, <a class="el" href="classAngle.html#a734e27903a01ed65bac0ed55cde728bc">Angle</a>, <a class="el" href="classDerivative.html#a734e27903a01ed65bac0ed55cde728bc">Derivative</a>, <a class="el" href="classVariable.html#a734e27903a01ed65bac0ed55cde728bc">Variable</a>, <a class="el" href="classATan.html#a734e27903a01ed65bac0ed55cde728bc">ATan</a>, <a class="el" href="classPow.html#a734e27903a01ed65bac0ed55cde728bc">Pow</a>, <a class="el" href="classASin.html#a734e27903a01ed65bac0ed55cde728bc">ASin</a>, <a class="el" href="classConstant.html#a734e27903a01ed65bac0ed55cde728bc">Constant</a>, <a class="el" href="classACos.html#a734e27903a01ed65bac0ed55cde728bc">ACos</a>, <a class="el" href="classFraction.html#a734e27903a01ed65bac0ed55cde728bc">Fraction</a>, <a class="el" href="classTan.html#a734e27903a01ed65bac0ed55cde728bc">Tan</a>, <a class="el" href="classCFraction.html#a734e27903a01ed65bac0ed55cde728bc">CFraction</a>, <a class="el" href="classTimes.html#a734e27903a01ed65bac0ed55cde728bc">Times</a>, <a class="el" href="classSin.html#a734e27903a01ed65bac0ed55cde728bc">Sin</a>, <a class="el" href="classCos.html#a734e27903a01ed65bac0ed55cde728bc">Cos</a>, <a class="el" href="classDouble.html#a734e27903a01ed65bac0ed55cde728bc">Double</a>, <a class="el" href="classLog.html#a734e27903a01ed65bac0ed55cde728bc">Log</a>, <a class="el" href="classPolynomial.html#a734e27903a01ed65bac0ed55cde728bc">Polynomial</a>, <a class="el" href="classInteger.html#a734e27903a01ed65bac0ed55cde728bc">Integer</a>, <a class="el" href="classExp.html#a734e27903a01ed65bac0ed55cde728bc">Exp</a>, <a class="el" href="classPlus.html#a734e27903a01ed65bac0ed55cde728bc">Plus</a>, and <a class="el" href="classAbs.html#a734e27903a01ed65bac0ed55cde728bc">Abs</a>.</p>

</div>
</div>
<a id="a9aebaa743c24d2faf6b9f2576c21a1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aebaa743c24d2faf6b9f2576c21a1df">&#9670;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> determinant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the determinant of the object if it corresponds to a square matrix (or a scalar), 0 else. </p>
<dl class="section return"><dt>Returns</dt><dd>det(<b>*this</b>) if <b>*this</b> is a square matrix or scalar. </dd>
<dd>
0 else. </dd></dl>

<p>Reimplemented in <a class="el" href="classMatrix.html#a513f51419fbea6ca79d6478918c34b76">Matrix</a>.</p>

</div>
</div>
<a id="a7cffcbbde45509935dd3179383dfcd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cffcbbde45509935dd3179383dfcd8c">&#9670;&nbsp;</a></span>develop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> develop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Develops</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full</td><td>If true the development is <b>recursive</b> through all the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The develop <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classPow.html#acf1ccb84aa901bcbba4394444d18c633">Pow</a>, <a class="el" href="classTimes.html#acf1ccb84aa901bcbba4394444d18c633">Times</a>, <a class="el" href="classAbstractMultiFunc.html#acf1ccb84aa901bcbba4394444d18c633">AbstractMultiFunc</a>, <a class="el" href="classAbstractDuoFunc.html#acf1ccb84aa901bcbba4394444d18c633">AbstractDuoFunc</a>, <a class="el" href="classAbstractVectorial.html#acf1ccb84aa901bcbba4394444d18c633">AbstractVectorial</a>, <a class="el" href="classAbstractFunc.html#acf1ccb84aa901bcbba4394444d18c633">AbstractFunc</a>, and <a class="el" href="classAbstractBuildingBlock.html#acf1ccb84aa901bcbba4394444d18c633">AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="ab218b3bc5d3930191ded81b2d689ab2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab218b3bc5d3930191ded81b2d689ab2d">&#9670;&nbsp;</a></span>division_own()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> division_own </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains implementation of special division for Numerical- and Polynomial-types. For polynomial, the euclidean division of two polynomials is implemented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Right operrand of the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The division of the two operands. </dd></dl>

<p>Reimplemented in <a class="el" href="classCFraction.html#a48c156a035694856e83ba42bfeba4d77">CFraction</a>, <a class="el" href="classDouble.html#a48c156a035694856e83ba42bfeba4d77">Double</a>, <a class="el" href="classPolynomial.html#a48c156a035694856e83ba42bfeba4d77">Polynomial</a>, and <a class="el" href="classInteger.html#a48c156a035694856e83ba42bfeba4d77">Integer</a>.</p>

</div>
</div>
<a id="a7ac2674de22496c96d6229eae2968fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac2674de22496c96d6229eae2968fdd">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of two <b>Vectorial</b> expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The right operand of the dot product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum _k (*this)[i,j,...,k]*expr[k,l,m,...]. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#aa8c453ee7313a36cc1c2987833a38d0e">AbstractVectorial</a>.</p>

</div>
</div>
<a id="ad803d52cf561b46554883cc14251788f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad803d52cf561b46554883cc14251788f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a1fc3ae6bd5c6a80e9b81b27fc7b7a11a">iter</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Expr&gt;::iterator at the end of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#ac02492275aeabe839fa74aa7952e7fad">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a77b8b381ee63c795f2ed54c36000b1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b8b381ee63c795f2ed54c36000b1ab">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#ac50bb217e67a9c51fa2b4322f56ec1a4">const_iter</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Expr&gt;::iterator at the end of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#acbd533082e1ba5a159f746c26828f132">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a02f313e9690045d548592ce82f9c365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f313e9690045d548592ce82f9c365c">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> evaluate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>Replaces all variables by their value and evaluating. This function must be used instead of <a class="el" href="classAbstract.html#abd473f3a4f62f338f5b0ee3b10453f39" title="Evaluates the value of the Abstract. ">evaluateScalar()</a> when treating not only real scalars.* In particular (x=2, y=3) x+iy evaluates to 3+ 3i whereas <a class="el" href="classAbstract.html#abd473f3a4f62f338f5b0ee3b10453f39" title="Evaluates the value of the Abstract. ">evaluateScalar()</a> would return 3. </p><dl class="section return"><dt>Returns</dt><dd>The abstract result of the evaluation. </dd></dl>

<p>Implemented in <a class="el" href="classFactorial.html#a9371625b49860dbbd2299b5de7043fe0">Factorial</a>, <a class="el" href="classImaginary.html#a9371625b49860dbbd2299b5de7043fe0">Imaginary</a>, <a class="el" href="classCFactorial.html#a9371625b49860dbbd2299b5de7043fe0">CFactorial</a>, <a class="el" href="classAngle.html#a9371625b49860dbbd2299b5de7043fe0">Angle</a>, <a class="el" href="classDerivative.html#a9371625b49860dbbd2299b5de7043fe0">Derivative</a>, <a class="el" href="classVariable.html#a9371625b49860dbbd2299b5de7043fe0">Variable</a>, <a class="el" href="classPow.html#a9371625b49860dbbd2299b5de7043fe0">Pow</a>, <a class="el" href="classITerm.html#a9371625b49860dbbd2299b5de7043fe0">ITerm</a>, <a class="el" href="classConstant.html#a9371625b49860dbbd2299b5de7043fe0">Constant</a>, <a class="el" href="classITensor.html#a9371625b49860dbbd2299b5de7043fe0">ITensor</a>, <a class="el" href="classFraction.html#a9371625b49860dbbd2299b5de7043fe0">Fraction</a>, <a class="el" href="classCFraction.html#a9371625b49860dbbd2299b5de7043fe0">CFraction</a>, <a class="el" href="classTimes.html#a9371625b49860dbbd2299b5de7043fe0">Times</a>, <a class="el" href="classDouble.html#a9371625b49860dbbd2299b5de7043fe0">Double</a>, <a class="el" href="classPolynomial.html#a9371625b49860dbbd2299b5de7043fe0">Polynomial</a>, <a class="el" href="classInteger.html#a9371625b49860dbbd2299b5de7043fe0">Integer</a>, <a class="el" href="classAbstractFunc.html#a9371625b49860dbbd2299b5de7043fe0">AbstractFunc</a>, <a class="el" href="classPlus.html#a9371625b49860dbbd2299b5de7043fe0">Plus</a>, <a class="el" href="classAbs.html#a9371625b49860dbbd2299b5de7043fe0">Abs</a>, and <a class="el" href="classAbstractVectorial.html#a9371625b49860dbbd2299b5de7043fe0">AbstractVectorial</a>.</p>

</div>
</div>
<a id="abd473f3a4f62f338f5b0ee3b10453f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd473f3a4f62f338f5b0ee3b10453f39">&#9670;&nbsp;</a></span>evaluateScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double evaluateScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the value of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>Tries to replace all variables by a real value. If it is not possible (for example treating a <a class="el" href="classVector.html">Vector</a> or an <a class="el" href="classImaginary.html" title="Numerical representation of i. ">Imaginary</a>) the considered object is replaced by 0. A warning message is displayed in the case of i. </p><dl class="section return"><dt>Returns</dt><dd>The value of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> (double). </dd></dl>

<p>Reimplemented in <a class="el" href="classFactorial.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Factorial</a>, <a class="el" href="classATanh.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">ATanh</a>, <a class="el" href="classASinh.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">ASinh</a>, <a class="el" href="classACosh.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">ACosh</a>, <a class="el" href="classTanh.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Tanh</a>, <a class="el" href="classSinh.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Sinh</a>, <a class="el" href="classImaginary.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Imaginary</a>, <a class="el" href="classCosh.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Cosh</a>, <a class="el" href="classCFactorial.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">CFactorial</a>, <a class="el" href="classAngle.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Angle</a>, <a class="el" href="classDerivative.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Derivative</a>, <a class="el" href="classVariable.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Variable</a>, <a class="el" href="classATan.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">ATan</a>, <a class="el" href="classASin.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">ASin</a>, <a class="el" href="classPow.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Pow</a>, <a class="el" href="classConstant.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Constant</a>, <a class="el" href="classACos.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">ACos</a>, <a class="el" href="classFraction.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Fraction</a>, <a class="el" href="classTan.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Tan</a>, <a class="el" href="classCFraction.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">CFraction</a>, <a class="el" href="classSin.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Sin</a>, <a class="el" href="classTimes.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Times</a>, <a class="el" href="classCos.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Cos</a>, <a class="el" href="classDouble.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Double</a>, <a class="el" href="classLog.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Log</a>, <a class="el" href="classPolynomial.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Polynomial</a>, <a class="el" href="classInteger.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Integer</a>, <a class="el" href="classExp.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Exp</a>, <a class="el" href="classPlus.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Plus</a>, and <a class="el" href="classAbs.html#ae9c688ffd0fe26da9d55d650ac1a6ba4">Abs</a>.</p>

</div>
</div>
<a id="abc999066a217b4fd767dadb5114d3698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc999066a217b4fd767dadb5114d3698">&#9670;&nbsp;</a></span>exponentiation_own()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> exponentiation_own </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains implementation of special exponentiation for Numerical- and Vectorial-types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponentiation of the two operands. </dd></dl>

<p>Reimplemented in <a class="el" href="classCFraction.html#a3f496e74b27b0d86fe16e259649353a2">CFraction</a>, <a class="el" href="classDouble.html#a3f496e74b27b0d86fe16e259649353a2">Double</a>, and <a class="el" href="classInteger.html#a3f496e74b27b0d86fe16e259649353a2">Integer</a>.</p>

</div>
</div>
<a id="a47214a866e4c0b5f9f0dcefc5aa1da39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47214a866e4c0b5f9f0dcefc5aa1da39">&#9670;&nbsp;</a></span>factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> factor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Factors</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>This function tries to factor the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt any <b>factor</b>. This will be more involved in calculation than the other factorizing function that takes the factor as a parameter. So this function <b>must be used only</b> if we don't know the factors we want at the end. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full</td><td>If true the factorization is <b>recursive</b> through all the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classAbstractMultiFunc.html#ad9d353d7c78473d62f37948937b41296">AbstractMultiFunc</a>, <a class="el" href="classPolynomial.html#ad9d353d7c78473d62f37948937b41296">Polynomial</a>, <a class="el" href="classAbstractDuoFunc.html#ad9d353d7c78473d62f37948937b41296">AbstractDuoFunc</a>, <a class="el" href="classAbstractVectorial.html#ad9d353d7c78473d62f37948937b41296">AbstractVectorial</a>, <a class="el" href="classPlus.html#ad9d353d7c78473d62f37948937b41296">Plus</a>, <a class="el" href="classAbstractFunc.html#ad9d353d7c78473d62f37948937b41296">AbstractFunc</a>, and <a class="el" href="classAbstractBuildingBlock.html#ad9d353d7c78473d62f37948937b41296">AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="a4fbe086f2cbc7fcdd072b8a29fe2abe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbe086f2cbc7fcdd072b8a29fe2abe6">&#9670;&nbsp;</a></span>factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> factor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Factors</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt a <b>particular</b> <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td><a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt which we try to factor. </td></tr>
    <tr><td class="paramname">full</td><td>If true the factorization is <b>recursive</b> through all the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classAbstractMultiFunc.html#afc5c1e823756b633e949f2fc6072e6fe">AbstractMultiFunc</a>, <a class="el" href="classAbstractDuoFunc.html#afc5c1e823756b633e949f2fc6072e6fe">AbstractDuoFunc</a>, <a class="el" href="classAbstractVectorial.html#afc5c1e823756b633e949f2fc6072e6fe">AbstractVectorial</a>, <a class="el" href="classPlus.html#afc5c1e823756b633e949f2fc6072e6fe">Plus</a>, <a class="el" href="classAbstractFunc.html#afc5c1e823756b633e949f2fc6072e6fe">AbstractFunc</a>, and <a class="el" href="classAbstractBuildingBlock.html#afc5c1e823756b633e949f2fc6072e6fe">AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="a6979d84d75c4d4057d961ad84043dbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6979d84d75c4d4057d961ad84043dbd9">&#9670;&nbsp;</a></span>getAlternateForms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt; getAlternateForms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns all possible alternate forms of the expression in terms of simplifications. For example 1-sin^2(x) is one of the alternate forms of cos^2(x). </p>
<p>Those alternate forms are then compared in terms of simplicity, this allows automatic simplification. Alternates are tried to simplify, and the bests are chosed. More details and algorithms in file alternateForms.cpp. </p><dl class="section return"><dt>Returns</dt><dd>A std::vector containing the alternate forms of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classTanh.html#a9ec4272e14880906aaebc6d2aa15cac6">Tanh</a>, <a class="el" href="classSinh.html#a9ec4272e14880906aaebc6d2aa15cac6">Sinh</a>, <a class="el" href="classCosh.html#a9ec4272e14880906aaebc6d2aa15cac6">Cosh</a>, <a class="el" href="classPow.html#a9ec4272e14880906aaebc6d2aa15cac6">Pow</a>, <a class="el" href="classTan.html#a9ec4272e14880906aaebc6d2aa15cac6">Tan</a>, <a class="el" href="classTimes.html#a9ec4272e14880906aaebc6d2aa15cac6">Times</a>, <a class="el" href="classSin.html#a9ec4272e14880906aaebc6d2aa15cac6">Sin</a>, <a class="el" href="classCos.html#a9ec4272e14880906aaebc6d2aa15cac6">Cos</a>, and <a class="el" href="classPlus.html#a9ec4272e14880906aaebc6d2aa15cac6">Plus</a>.</p>

</div>
</div>
<a id="aa3dab23c4d96c188bd24d38ad69eba20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dab23c4d96c188bd24d38ad69eba20">&#9670;&nbsp;</a></span>getArgument() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getArgument </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iArg</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This function must not be called for building blocks, one must check first that the expression has arguments. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The i^{th} argument of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classITerm.html#ae61b5bdbc1b2651da335257b057e7491">ITerm</a>, <a class="el" href="classAbstractMultiFunc.html#ae61b5bdbc1b2651da335257b057e7491">AbstractMultiFunc</a>, <a class="el" href="classAbstractDuoFunc.html#ae61b5bdbc1b2651da335257b057e7491">AbstractDuoFunc</a>, <a class="el" href="classAbstractFunc.html#ae61b5bdbc1b2651da335257b057e7491">AbstractFunc</a>, and <a class="el" href="classAbstractVectorial.html#ae61b5bdbc1b2651da335257b057e7491">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a4af92cbaad45ffb4e114b90038cc1495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af92cbaad45ffb4e114b90038cc1495">&#9670;&nbsp;</a></span>getArgument() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getArgument </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must not be called for building blocks, one must check first that the expression has arguments. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The argument {i,j,...} of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#ad9465ac47b8a768dec6e08daa1376777">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a8a803192766a3af8cc52747e6be2258b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a803192766a3af8cc52747e6be2258b">&#9670;&nbsp;</a></span>getArgument() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getArgument </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must not be called for building blocks, one must check first that the expression has arguments. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The argument {i,j,...} of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#ab04856666aedc3cea3052858844947d7">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a008f58643c15d4f624e6aee7a98e699c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008f58643c15d4f624e6aee7a98e699c">&#9670;&nbsp;</a></span>getCommutable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool getCommutable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to know if the object commutes with all the others. </p>
<dl class="section return"><dt>Returns</dt><dd><em>commutable</em> </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractMultiFunc.html#a2a2df4eea5a20c002f58e0d1f41550f0">AbstractMultiFunc</a>, <a class="el" href="classAbstractDuoFunc.html#a2a2df4eea5a20c002f58e0d1f41550f0">AbstractDuoFunc</a>, and <a class="el" href="classAbstractFunc.html#a2a2df4eea5a20c002f58e0d1f41550f0">AbstractFunc</a>.</p>

</div>
</div>
<a id="a0a594594ebcc69a4945ab6890e203deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a594594ebcc69a4945ab6890e203deb">&#9670;&nbsp;</a></span>getComplexArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getComplexArgument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>argument in the complex plane</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The argument part of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classATanh.html#a3d06a129ca3e2e920aecf3e4432c149e">ATanh</a>, <a class="el" href="classASinh.html#a3d06a129ca3e2e920aecf3e4432c149e">ASinh</a>, <a class="el" href="classACosh.html#a3d06a129ca3e2e920aecf3e4432c149e">ACosh</a>, <a class="el" href="classTanh.html#a3d06a129ca3e2e920aecf3e4432c149e">Tanh</a>, <a class="el" href="classSinh.html#a3d06a129ca3e2e920aecf3e4432c149e">Sinh</a>, <a class="el" href="classImaginary.html#a3d06a129ca3e2e920aecf3e4432c149e">Imaginary</a>, <a class="el" href="classCosh.html#a3d06a129ca3e2e920aecf3e4432c149e">Cosh</a>, <a class="el" href="classPow.html#a3d06a129ca3e2e920aecf3e4432c149e">Pow</a>, <a class="el" href="classASin.html#a3d06a129ca3e2e920aecf3e4432c149e">ASin</a>, <a class="el" href="classACos.html#a3d06a129ca3e2e920aecf3e4432c149e">ACos</a>, <a class="el" href="classTan.html#a3d06a129ca3e2e920aecf3e4432c149e">Tan</a>, <a class="el" href="classSin.html#a3d06a129ca3e2e920aecf3e4432c149e">Sin</a>, <a class="el" href="classTimes.html#a3d06a129ca3e2e920aecf3e4432c149e">Times</a>, <a class="el" href="classCos.html#a3d06a129ca3e2e920aecf3e4432c149e">Cos</a>, <a class="el" href="classLog.html#a3d06a129ca3e2e920aecf3e4432c149e">Log</a>, <a class="el" href="classExp.html#a3d06a129ca3e2e920aecf3e4432c149e">Exp</a>, and <a class="el" href="classPlus.html#a3d06a129ca3e2e920aecf3e4432c149e">Plus</a>.</p>

</div>
</div>
<a id="a3317c522a29f999c5631d7e3b6431372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3317c522a29f999c5631d7e3b6431372">&#9670;&nbsp;</a></span>getComplexConjugate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getComplexConjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the complex conjugate of the expression. </p>
<dl class="section return"><dt>Returns</dt><dd>{*this}. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractFunc.html#ac462bb892fd93f682ef0fa10834315a0">AbstractFunc</a>.</p>

</div>
</div>
<a id="aff23826dac23c21b39a9d4ef59d50c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff23826dac23c21b39a9d4ef59d50c76">&#9670;&nbsp;</a></span>getComplexModulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getComplexModulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>modulus in the complex plane</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The modulus part of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classATanh.html#ab4dc712689d15bfa67e816bbd0426ab3">ATanh</a>, <a class="el" href="classASinh.html#ab4dc712689d15bfa67e816bbd0426ab3">ASinh</a>, <a class="el" href="classACosh.html#ab4dc712689d15bfa67e816bbd0426ab3">ACosh</a>, <a class="el" href="classTanh.html#ab4dc712689d15bfa67e816bbd0426ab3">Tanh</a>, <a class="el" href="classSinh.html#ab4dc712689d15bfa67e816bbd0426ab3">Sinh</a>, <a class="el" href="classImaginary.html#ab4dc712689d15bfa67e816bbd0426ab3">Imaginary</a>, <a class="el" href="classCosh.html#ab4dc712689d15bfa67e816bbd0426ab3">Cosh</a>, <a class="el" href="classPow.html#ab4dc712689d15bfa67e816bbd0426ab3">Pow</a>, <a class="el" href="classASin.html#ab4dc712689d15bfa67e816bbd0426ab3">ASin</a>, <a class="el" href="classACos.html#ab4dc712689d15bfa67e816bbd0426ab3">ACos</a>, <a class="el" href="classTan.html#ab4dc712689d15bfa67e816bbd0426ab3">Tan</a>, <a class="el" href="classSin.html#ab4dc712689d15bfa67e816bbd0426ab3">Sin</a>, <a class="el" href="classTimes.html#ab4dc712689d15bfa67e816bbd0426ab3">Times</a>, <a class="el" href="classCos.html#ab4dc712689d15bfa67e816bbd0426ab3">Cos</a>, <a class="el" href="classLog.html#ab4dc712689d15bfa67e816bbd0426ab3">Log</a>, <a class="el" href="classExp.html#ab4dc712689d15bfa67e816bbd0426ab3">Exp</a>, <a class="el" href="classPlus.html#ab4dc712689d15bfa67e816bbd0426ab3">Plus</a>, and <a class="el" href="classAbstractBuildingBlock.html#ab4dc712689d15bfa67e816bbd0426ab3">AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="a55fa50ffd1b16b2ff0ad421a3a0760c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fa50ffd1b16b2ff0ad421a3a0760c1">&#9670;&nbsp;</a></span>getContractedPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; pair&lt; int, int &gt; &gt; getContractedPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>All contracted pairs of indices of an <b>Indicial</b> expression. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not yet well implemented and may not be useful in the future. </dd></dl>

</div>
</div>
<a id="a2a452f6609a695e82dbec0924fe6ad53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a452f6609a695e82dbec0924fe6ad53">&#9670;&nbsp;</a></span>getDenom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getDenom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The denominator for a <a class="el" href="classCFraction.html" title="Handles fractions of Number. ">CFraction</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCFraction.html#ab4acac5a2cd9449f063094c8bab94261">CFraction</a>.</p>

</div>
</div>
<a id="a08975678f3024274380d3502839b0d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08975678f3024274380d3502839b0d10">&#9670;&nbsp;</a></span>getDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int getDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <b>dimension</b> of the object. </p>
<p>Allows to know if we are manipulating a pure scalar (i.e. that can have a real value) or something else. There is the particular case of the <a class="el" href="classImaginary.html" title="Numerical representation of i. ">Imaginary</a> <b>i</b> that is considered as a scalar for simplicity but in reality cannot be evaluated with a real. Example: 1 + <b>i</b> cannot be reduced. </p><dl class="section return"><dt>Returns</dt><dd>dim (a non memorized integer corresponding to the dimension of the abstract) </dd></dl>

<p>Implemented in <a class="el" href="classAbstractScalar.html#a611142e741518fc0745828678d1dfd7f">AbstractScalar</a>, and <a class="el" href="classAbstractVectorial.html#a611142e741518fc0745828678d1dfd7f">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a5fdf2d5371e8c8ead87ef2b5d6fe43c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fdf2d5371e8c8ead87ef2b5d6fe43c0">&#9670;&nbsp;</a></span>getFactors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt; getFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to get a std::vector of all terms than could factor the expression. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector containing the possible factors of <b>*this</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classPow.html#acee0097dec8a4e721575bd38c830c81d">Pow</a>, <a class="el" href="classFraction.html#acee0097dec8a4e721575bd38c830c81d">Fraction</a>, and <a class="el" href="classTimes.html#acee0097dec8a4e721575bd38c830c81d">Times</a>.</p>

</div>
</div>
<a id="a6fc37867d634b3538379f6256d6c7e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc37867d634b3538379f6256d6c7e29">&#9670;&nbsp;</a></span>getImaginaryPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getImaginaryPart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>imaginary part</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The imaginary part of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classATanh.html#a71aea8e6392b27ef3c114c3e04908e0c">ATanh</a>, <a class="el" href="classASinh.html#a71aea8e6392b27ef3c114c3e04908e0c">ASinh</a>, <a class="el" href="classACosh.html#a71aea8e6392b27ef3c114c3e04908e0c">ACosh</a>, <a class="el" href="classTanh.html#a71aea8e6392b27ef3c114c3e04908e0c">Tanh</a>, <a class="el" href="classSinh.html#a71aea8e6392b27ef3c114c3e04908e0c">Sinh</a>, <a class="el" href="classImaginary.html#a71aea8e6392b27ef3c114c3e04908e0c">Imaginary</a>, <a class="el" href="classCosh.html#a71aea8e6392b27ef3c114c3e04908e0c">Cosh</a>, <a class="el" href="classPow.html#a71aea8e6392b27ef3c114c3e04908e0c">Pow</a>, <a class="el" href="classASin.html#a71aea8e6392b27ef3c114c3e04908e0c">ASin</a>, <a class="el" href="classACos.html#a71aea8e6392b27ef3c114c3e04908e0c">ACos</a>, <a class="el" href="classTan.html#a71aea8e6392b27ef3c114c3e04908e0c">Tan</a>, <a class="el" href="classSin.html#a71aea8e6392b27ef3c114c3e04908e0c">Sin</a>, <a class="el" href="classTimes.html#a71aea8e6392b27ef3c114c3e04908e0c">Times</a>, <a class="el" href="classCos.html#a71aea8e6392b27ef3c114c3e04908e0c">Cos</a>, <a class="el" href="classLog.html#a71aea8e6392b27ef3c114c3e04908e0c">Log</a>, <a class="el" href="classExp.html#a71aea8e6392b27ef3c114c3e04908e0c">Exp</a>, and <a class="el" href="classPlus.html#a71aea8e6392b27ef3c114c3e04908e0c">Plus</a>.</p>

</div>
</div>
<a id="ad0d151ec6c57077235d5664cdc993827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d151ec6c57077235d5664cdc993827">&#9670;&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndex.html">Index</a> getIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Spot of the index to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the i^{th} index of an <b>Indicial</b> expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classITensor.html#ad6b9a0cefb4ceee872a4dad4596cda0a">ITensor</a>.</p>

</div>
</div>
<a id="a6bd19eb640458e6e70ddaf35115aa2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd19eb640458e6e70ddaf35115aa2d2">&#9670;&nbsp;</a></span>getIndexStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexStructure.html">IndexStructure</a> getIndexStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The index structure of the <b>Indicial</b> expression </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractIndicial.html#a25fe2ce3cbe7c2c91345085485089a5a">AbstractIndicial</a>, <a class="el" href="classTimes.html#a25fe2ce3cbe7c2c91345085485089a5a">Times</a>, <a class="el" href="classPolynomial.html#a25fe2ce3cbe7c2c91345085485089a5a">Polynomial</a>, <a class="el" href="classAbstractDuoFunc.html#a25fe2ce3cbe7c2c91345085485089a5a">AbstractDuoFunc</a>, <a class="el" href="classAbstractFunc.html#a25fe2ce3cbe7c2c91345085485089a5a">AbstractFunc</a>, and <a class="el" href="classPlus.html#a25fe2ce3cbe7c2c91345085485089a5a">Plus</a>.</p>

</div>
</div>
<a id="a8a60438a5b55d0b2ceb35c8674b9d8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a60438a5b55d0b2ceb35c8674b9d8c5">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>'s name. </p>
<dl class="section return"><dt>Returns</dt><dd><em>name</em> </dd></dl>

</div>
</div>
<a id="a3f9edafbda64687e956edd3710d52363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9edafbda64687e956edd3710d52363">&#9670;&nbsp;</a></span>getNArgs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getNArgs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of arguments of the expression. If the expression is a building block (<a class="el" href="classAbstractBuildingBlock.html" title="Abstract class from which derive all building blocks of exprs, i.e. objects not function of further e...">AbstractBuildingBlock</a>), this function returns 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of arguments of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classITerm.html#a543e3e72f78bf20e1d63630404566262">ITerm</a>, <a class="el" href="classAbstractMultiFunc.html#a543e3e72f78bf20e1d63630404566262">AbstractMultiFunc</a>, <a class="el" href="classAbstractDuoFunc.html#a543e3e72f78bf20e1d63630404566262">AbstractDuoFunc</a>, <a class="el" href="classAbstractFunc.html#a543e3e72f78bf20e1d63630404566262">AbstractFunc</a>, and <a class="el" href="classAbstractVectorial.html#a543e3e72f78bf20e1d63630404566262">AbstractVectorial</a>.</p>

</div>
</div>
<a id="ae39a18f5d58508346e4c19d3c26a80d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39a18f5d58508346e4c19d3c26a80d4">&#9670;&nbsp;</a></span>getNContractedPairs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getNContractedPairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of contracted pairs of indices <b>in an Indicial expression</b>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of contracted pairs of indices. </dd></dl>

</div>
</div>
<a id="a594a570f0139f92f284f31e91c0c6dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594a570f0139f92f284f31e91c0c6dd8">&#9670;&nbsp;</a></span>getNFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getNFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of possible factors for the expression </dd></dl>

<p>Reimplemented in <a class="el" href="classPow.html#ac2bc6e6cd2c5da919e3987ef31170357">Pow</a>, <a class="el" href="classFraction.html#ac2bc6e6cd2c5da919e3987ef31170357">Fraction</a>, and <a class="el" href="classTimes.html#ac2bc6e6cd2c5da919e3987ef31170357">Times</a>.</p>

</div>
</div>
<a id="ac702310492abaed2dfef1ee4d988d7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac702310492abaed2dfef1ee4d988d7c2">&#9670;&nbsp;</a></span>getNIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getNIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of indices of an <b>Indicial</b> expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractIndicial.html#a6e562de12984d1b2727b8de765654024">AbstractIndicial</a>.</p>

</div>
</div>
<a id="afa98d0f2d18bf275f6654a7fadd538e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa98d0f2d18bf275f6654a7fadd538e4">&#9670;&nbsp;</a></span>getNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The numerator for a <a class="el" href="classCFraction.html" title="Handles fractions of Number. ">CFraction</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCFraction.html#a55c2e0bab4a6430534af8a9af3a90b56">CFraction</a>.</p>

</div>
</div>
<a id="a839372b7667ea0a28a9e3b72112366ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839372b7667ea0a28a9e3b72112366ff">&#9670;&nbsp;</a></span>getNumericalFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getNumericalFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the numerical factor of the expression, i.e. returns <b>C</b> if the expression if of the form <b>C*x</b> (<b>x</b> having a numerical factor equal to 1), and return 1 else. </p>
<dl class="section note"><dt>Note</dt><dd>This function returns the factor in an Expression (then of Numerical type). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The numerical factor in front of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classTimes.html#a0678331620669f2ad08c32a88615fe8c">Times</a>.</p>

</div>
</div>
<a id="a6d7f724371bd2b5c61d3615faef63beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7f724371bd2b5c61d3615faef63beb">&#9670;&nbsp;</a></span>getOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to the order (integer) that defines certain types of expressions. </p>
<dl class="section return"><dt>Returns</dt><dd><b>order</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classDerivative.html#a4dc5fc366b596dfae10eec764583e5ca">Derivative</a>, and <a class="el" href="classPolynomial.html#a4dc5fc366b596dfae10eec764583e5ca">Polynomial</a>.</p>

</div>
</div>
<a id="a7960d79b133f222a433de92b9562c7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7960d79b133f222a433de92b9562c7cc">&#9670;&nbsp;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndicialParent.html">IndicialParent</a> * getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For indicial expressions this function returns a pointer to the parent object of type <a class="el" href="classIndicialParent.html">IndicialParent</a> (not an expression). </p>
<dl class="section return"><dt>Returns</dt><dd><b>parent</b> for ITensor-type expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classITensor.html#a8529c694aed6f2daf6ff5d2f9747b121">ITensor</a>.</p>

</div>
</div>
<a id="a950163457cbd6cef954422a1821eda7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950163457cbd6cef954422a1821eda7a">&#9670;&nbsp;</a></span>getParity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getParity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>t_variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parity property of the expression with respect to <b>t_variable</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_variable.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the expression is <b>even</b> in <b>t_variable</b>. </dd>
<dd>
-1 if the expression is <b>odd</b> in <b>t_variable</b>. </dd>
<dd>
0 else. </dd></dl>

<p>Reimplemented in <a class="el" href="classFactorial.html#aa90ed274a34d81fdea756d81a74783dc">Factorial</a>, <a class="el" href="classATanh.html#aa90ed274a34d81fdea756d81a74783dc">ATanh</a>, <a class="el" href="classASinh.html#aa90ed274a34d81fdea756d81a74783dc">ASinh</a>, <a class="el" href="classACosh.html#aa90ed274a34d81fdea756d81a74783dc">ACosh</a>, <a class="el" href="classTanh.html#aa90ed274a34d81fdea756d81a74783dc">Tanh</a>, <a class="el" href="classSinh.html#aa90ed274a34d81fdea756d81a74783dc">Sinh</a>, <a class="el" href="classCosh.html#aa90ed274a34d81fdea756d81a74783dc">Cosh</a>, <a class="el" href="classAngle.html#aa90ed274a34d81fdea756d81a74783dc">Angle</a>, <a class="el" href="classDerivative.html#aa90ed274a34d81fdea756d81a74783dc">Derivative</a>, <a class="el" href="classVariable.html#aa90ed274a34d81fdea756d81a74783dc">Variable</a>, <a class="el" href="classATan.html#aa90ed274a34d81fdea756d81a74783dc">ATan</a>, <a class="el" href="classPow.html#aa90ed274a34d81fdea756d81a74783dc">Pow</a>, <a class="el" href="classASin.html#aa90ed274a34d81fdea756d81a74783dc">ASin</a>, <a class="el" href="classConstant.html#aa90ed274a34d81fdea756d81a74783dc">Constant</a>, <a class="el" href="classACos.html#aa90ed274a34d81fdea756d81a74783dc">ACos</a>, <a class="el" href="classFraction.html#aa90ed274a34d81fdea756d81a74783dc">Fraction</a>, <a class="el" href="classTan.html#aa90ed274a34d81fdea756d81a74783dc">Tan</a>, <a class="el" href="classTimes.html#aa90ed274a34d81fdea756d81a74783dc">Times</a>, <a class="el" href="classSin.html#aa90ed274a34d81fdea756d81a74783dc">Sin</a>, <a class="el" href="classCos.html#aa90ed274a34d81fdea756d81a74783dc">Cos</a>, <a class="el" href="classLog.html#aa90ed274a34d81fdea756d81a74783dc">Log</a>, <a class="el" href="classPolynomial.html#aa90ed274a34d81fdea756d81a74783dc">Polynomial</a>, <a class="el" href="classExp.html#aa90ed274a34d81fdea756d81a74783dc">Exp</a>, <a class="el" href="classPlus.html#aa90ed274a34d81fdea756d81a74783dc">Plus</a>, and <a class="el" href="classAbs.html#aa90ed274a34d81fdea756d81a74783dc">Abs</a>.</p>

</div>
</div>
<a id="a13bc1c2804eeb41a6ce2eaca0d741cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bc1c2804eeb41a6ce2eaca0d741cf8">&#9670;&nbsp;</a></span>getPermutations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt; getPermutations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a std::vector of all possible permutations of an <b>Indicial</b> expression. The possible permutations are determined from the posible symmetries and anti-symmetries of the object. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector containing all possible permutations of the tensor. </dd></dl>

<p>Reimplemented in <a class="el" href="classITensor.html#a292bbda4c1fb9df300ff8baf3798d781">ITensor</a>.</p>

</div>
</div>
<a id="a69fa7ef6049a03bb02382ee6f6cde2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fa7ef6049a03bb02382ee6f6cde2f9">&#9670;&nbsp;</a></span>getPolynomialTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getPolynomialTerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>t_variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the polynomial term corresponding to <b>*this</b> with the variable <b>t_variable</b> at order <b>order</b>. In particular, this function assumes that the checks have already been made with the function <a class="el" href="classAbstract.html#af5fb27a847c4aceb353cce8183df51be" title="Determines if the expression is a mononomial term in expr, i.e. a term of the form C*expr^n with C in...">isPolynomial()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_variable</td><td><a class="el" href="classVariable.html" title="Handle an object with a name and a value. ">Variable</a> of the polynomial.  Order of <b>*this</b> in <b>t_variable</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same expression as (*this) with the term <b>t_variable^order</b> removed. </dd></dl>

<p>Reimplemented in <a class="el" href="classPow.html#a4f53ffbf9f3f7e810754da1938db3254">Pow</a>, <a class="el" href="classFraction.html#a4f53ffbf9f3f7e810754da1938db3254">Fraction</a>, <a class="el" href="classTimes.html#a4f53ffbf9f3f7e810754da1938db3254">Times</a>, and <a class="el" href="classAbstractBuildingBlock.html#a2c9eb0478ef1ecd05949a1eeb8578b18">AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="ae8ca7706d5195bafe639907377239b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ca7706d5195bafe639907377239b30">&#9670;&nbsp;</a></span>getPrimaryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="abstract_8h.html#a8e2e97c94555dae36453ba3c507db79e">smType::PrimaryType</a> getPrimaryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <b>primary</b> <b>type</b> of <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (single number, scalar function with one argument, with multiple argumments, a <a class="el" href="classVector.html">Vector</a>, etc) in order to do special treatments or simplifications. </p><dl class="section return"><dt>Returns</dt><dd>type (a non memorized integer corresponding to the type of abstract) </dd></dl>

<p>Implemented in <a class="el" href="classImaginary.html#a6e4c472299ada58b0101d4e70c574105">Imaginary</a>, <a class="el" href="classCFactorial.html#a6e4c472299ada58b0101d4e70c574105">CFactorial</a>, <a class="el" href="classVariable.html#a6e4c472299ada58b0101d4e70c574105">Variable</a>, <a class="el" href="classConstant.html#a6e4c472299ada58b0101d4e70c574105">Constant</a>, <a class="el" href="classAbstractIndicial.html#a6e4c472299ada58b0101d4e70c574105">AbstractIndicial</a>, <a class="el" href="classAbstractMultiFunc.html#adc6c00c28c8d6b477efc8160692a09d8">AbstractMultiFunc</a>, <a class="el" href="classAbstractDuoFunc.html#a6e4c472299ada58b0101d4e70c574105">AbstractDuoFunc</a>, <a class="el" href="classAbstractLiteral.html#a6e4c472299ada58b0101d4e70c574105">AbstractLiteral</a>, <a class="el" href="classAbstractNumerical.html#a6e4c472299ada58b0101d4e70c574105">AbstractNumerical</a>, <a class="el" href="classAbstractFunc.html#a6e4c472299ada58b0101d4e70c574105">AbstractFunc</a>, and <a class="el" href="classAbstractVectorial.html#a6e4c472299ada58b0101d4e70c574105">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a97407d5f8eb14ece9c7335d56930640c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97407d5f8eb14ece9c7335d56930640c">&#9670;&nbsp;</a></span>getProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getProduct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the product of all elements in the <b>Vectorial</b> object. </p>
<dl class="section return"><dt>Returns</dt><dd>The product of all elements. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#ace60e29a30276591e831a5b7c7660e5d">AbstractVectorial</a>.</p>

</div>
</div>
<a id="afc3cdd2b7bf7c6a6df773b68c9af5153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3cdd2b7bf7c6a6df773b68c9af5153">&#9670;&nbsp;</a></span>getRealPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getRealPart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>real part</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The real part of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classATanh.html#a3796711e63a2d5a048d44475e9c78f01">ATanh</a>, <a class="el" href="classASinh.html#a3796711e63a2d5a048d44475e9c78f01">ASinh</a>, <a class="el" href="classACosh.html#a3796711e63a2d5a048d44475e9c78f01">ACosh</a>, <a class="el" href="classTanh.html#a3796711e63a2d5a048d44475e9c78f01">Tanh</a>, <a class="el" href="classSinh.html#a3796711e63a2d5a048d44475e9c78f01">Sinh</a>, <a class="el" href="classImaginary.html#a3796711e63a2d5a048d44475e9c78f01">Imaginary</a>, <a class="el" href="classCosh.html#a3796711e63a2d5a048d44475e9c78f01">Cosh</a>, <a class="el" href="classPow.html#a3796711e63a2d5a048d44475e9c78f01">Pow</a>, <a class="el" href="classASin.html#a3796711e63a2d5a048d44475e9c78f01">ASin</a>, <a class="el" href="classACos.html#a3796711e63a2d5a048d44475e9c78f01">ACos</a>, <a class="el" href="classTan.html#a3796711e63a2d5a048d44475e9c78f01">Tan</a>, <a class="el" href="classSin.html#a3796711e63a2d5a048d44475e9c78f01">Sin</a>, <a class="el" href="classTimes.html#a3796711e63a2d5a048d44475e9c78f01">Times</a>, <a class="el" href="classCos.html#a3796711e63a2d5a048d44475e9c78f01">Cos</a>, <a class="el" href="classLog.html#a3796711e63a2d5a048d44475e9c78f01">Log</a>, <a class="el" href="classExp.html#a3796711e63a2d5a048d44475e9c78f01">Exp</a>, <a class="el" href="classPlus.html#a3796711e63a2d5a048d44475e9c78f01">Plus</a>, and <a class="el" href="classAbstractBuildingBlock.html#a3796711e63a2d5a048d44475e9c78f01">AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="ab5e5fc56dcab6f16259d0e6925aa51c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e5fc56dcab6f16259d0e6925aa51c0">&#9670;&nbsp;</a></span>getRegularExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getRegularExpression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a regular expression from the polynomial, that is a sum where the different powers of the variable appear explicitely. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classPlus.html" title="Handles a sum, function of multiple arguments. ">Plus</a> expression equal to the polynomial. </dd></dl>

<p>Reimplemented in <a class="el" href="classPolynomial.html#a4255955f6160c13202fbb154f5efde39">Polynomial</a>.</p>

</div>
</div>
<a id="acc79aa416f0937aa5c5c5ba07370a037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc79aa416f0937aa5c5c5ba07370a037">&#9670;&nbsp;</a></span>getShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; getShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to the shape of the tensor in the form of a std::vector of integers. </p>
<dl class="section return"><dt>Returns</dt><dd><b>shape</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#aa1b37ecbfc5dcafa0325439f72fdb32a">AbstractVectorial</a>.</p>

</div>
</div>
<a id="ab57bb5ebdd5cd06237267a4c26b61590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57bb5ebdd5cd06237267a4c26b61590">&#9670;&nbsp;</a></span>getSubVectorial() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getSubVectorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iExcept</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iExcept</td><td>Element to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The part of *this excluding iExcept. </dd></dl>

<p>Reimplemented in <a class="el" href="classVector.html#a37cddc25baff0218e420e31f0038ba04">Vector</a>.</p>

</div>
</div>
<a id="a409da64180d33314dc802014dc6d963f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409da64180d33314dc802014dc6d963f">&#9670;&nbsp;</a></span>getSubVectorial() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getSubVectorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iExcept</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jExcept</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to pick a part of a Vectorial expression, excluding the [iExcept^{th},jExcept^{th}] element (useful for matrices). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iExcept</td><td>Element of the first axis to ignore. </td></tr>
    <tr><td class="paramname">jExcept</td><td>Element of the second axis to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The part of *this excluding iExcept. </dd></dl>

<p>Reimplemented in <a class="el" href="classMatrix.html#a6c4abc5525b38c04f4fffed517214d74">Matrix</a>.</p>

</div>
</div>
<a id="a77756abf1144b00e44eafabd582740fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77756abf1144b00e44eafabd582740fe">&#9670;&nbsp;</a></span>getSubVectorial() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getSubVectorial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>exceptions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iExcept</td><td>Element to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The part of *this excluding iExcept. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#af94e57a145012ad9e6d75e9b33501a98">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a8ba9f54b32db597435e94cf8645175e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba9f54b32db597435e94cf8645175e6">&#9670;&nbsp;</a></span>getSum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getSum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the sum of all elements in the <b>Vectorial</b> object. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of all elements. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#afffa89e0d4c9e3a8bb3aa5959249ab55">AbstractVectorial</a>.</p>

</div>
</div>
<a id="ad4eab0d3915f47bc492ecaaf508afca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4eab0d3915f47bc492ecaaf508afca4">&#9670;&nbsp;</a></span>getTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the same expression as *this but amputated of its numerical factor. Example: (4*cos(x) -&gt; cos(x)). </p>
<dl class="section return"><dt>Returns</dt><dd>The term without numerical factor corresponding to <b>*this</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classTimes.html#abfb9626259e3fb5e719f638cff60b316">Times</a>, and <a class="el" href="classAbstractBuildingBlock.html#abfb9626259e3fb5e719f638cff60b316">AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="ac545afdeb8b1724b1e8aff98b059b52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac545afdeb8b1724b1e8aff98b059b52c">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="abstract_8h.html#a1d1cfd8ffb84e947f82999c682b666a7">smType::Type</a> getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <b>type</b> of <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (cos, product, number, etc) in order to do special treatments or simplifications. </p><dl class="section return"><dt>Returns</dt><dd>type (a non memorized integer corresponding to the type of abstract) </dd></dl>

<p>Implemented in <a class="el" href="classFactorial.html#a7e3d0659d118ba83932b71540239d0b5">Factorial</a>, <a class="el" href="classATanh.html#a7e3d0659d118ba83932b71540239d0b5">ATanh</a>, <a class="el" href="classASinh.html#a7e3d0659d118ba83932b71540239d0b5">ASinh</a>, <a class="el" href="classACosh.html#a7e3d0659d118ba83932b71540239d0b5">ACosh</a>, <a class="el" href="classTanh.html#a7e3d0659d118ba83932b71540239d0b5">Tanh</a>, <a class="el" href="classSinh.html#a7e3d0659d118ba83932b71540239d0b5">Sinh</a>, <a class="el" href="classImaginary.html#a7e3d0659d118ba83932b71540239d0b5">Imaginary</a>, <a class="el" href="classCosh.html#a7e3d0659d118ba83932b71540239d0b5">Cosh</a>, <a class="el" href="classCFactorial.html#a7e3d0659d118ba83932b71540239d0b5">CFactorial</a>, <a class="el" href="classAngle.html#a7e3d0659d118ba83932b71540239d0b5">Angle</a>, <a class="el" href="classDerivative.html#a7e3d0659d118ba83932b71540239d0b5">Derivative</a>, <a class="el" href="classATan.html#a7e3d0659d118ba83932b71540239d0b5">ATan</a>, <a class="el" href="classVariable.html#a7e3d0659d118ba83932b71540239d0b5">Variable</a>, <a class="el" href="classASin.html#a7e3d0659d118ba83932b71540239d0b5">ASin</a>, <a class="el" href="classPow.html#a7e3d0659d118ba83932b71540239d0b5">Pow</a>, <a class="el" href="classITerm.html#a7e3d0659d118ba83932b71540239d0b5">ITerm</a>, <a class="el" href="classConstant.html#a7e3d0659d118ba83932b71540239d0b5">Constant</a>, <a class="el" href="classACos.html#a7e3d0659d118ba83932b71540239d0b5">ACos</a>, <a class="el" href="classITensor.html#a7e3d0659d118ba83932b71540239d0b5">ITensor</a>, <a class="el" href="classFraction.html#a7e3d0659d118ba83932b71540239d0b5">Fraction</a>, <a class="el" href="classTan.html#a7e3d0659d118ba83932b71540239d0b5">Tan</a>, <a class="el" href="classCFraction.html#a7e3d0659d118ba83932b71540239d0b5">CFraction</a>, <a class="el" href="classSin.html#a7e3d0659d118ba83932b71540239d0b5">Sin</a>, <a class="el" href="classTimes.html#a7e3d0659d118ba83932b71540239d0b5">Times</a>, <a class="el" href="classCos.html#a7e3d0659d118ba83932b71540239d0b5">Cos</a>, <a class="el" href="classHighDTensor.html#a7e3d0659d118ba83932b71540239d0b5">HighDTensor</a>, <a class="el" href="classDouble.html#a7e3d0659d118ba83932b71540239d0b5">Double</a>, <a class="el" href="classLog.html#a7e3d0659d118ba83932b71540239d0b5">Log</a>, <a class="el" href="classMatrix.html#a7e3d0659d118ba83932b71540239d0b5">Matrix</a>, <a class="el" href="classPolynomial.html#a7e3d0659d118ba83932b71540239d0b5">Polynomial</a>, <a class="el" href="classVector.html#a7e3d0659d118ba83932b71540239d0b5">Vector</a>, <a class="el" href="classInteger.html#a7e3d0659d118ba83932b71540239d0b5">Integer</a>, <a class="el" href="classExp.html#a7e3d0659d118ba83932b71540239d0b5">Exp</a>, <a class="el" href="classPlus.html#a7e3d0659d118ba83932b71540239d0b5">Plus</a>, and <a class="el" href="classAbs.html#a7e3d0659d118ba83932b71540239d0b5">Abs</a>.</p>

</div>
</div>
<a id="acba57b14ff887eea4ef9e031d69374cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba57b14ff887eea4ef9e031d69374cb">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double getValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the expression, if it has one <b>explicitely</b>. In particular, it will work only on Numbers and valued Literals, not on functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classCFactorial.html#a679aaae054cd9e3558f4c65e4e95f883">CFactorial</a>, and <a class="el" href="classVariable.html#a679aaae054cd9e3558f4c65e4e95f883">Variable</a>.</p>

</div>
</div>
<a id="ac57c83bb6e902a6a15a361e3b23fc5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57c83bb6e902a6a15a361e3b23fc5df">&#9670;&nbsp;</a></span>getValued()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool getValued </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if the expression is valued, i.e. is a function of numbers and valued literals (a <a class="el" href="classVariable.html" title="Handle an object with a name and a value. ">Variable</a> or <a class="el" href="classConstant.html" title="Handle an object with a name and a value. ">Constant</a> is not valued by default). </p>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is valued. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classVariable.html#a0a7c351d50c91722bd6b1f0c8d8f3081">Variable</a>, and <a class="el" href="classConstant.html#a0a7c351d50c91722bd6b1f0c8d8f3081">Constant</a>.</p>

</div>
</div>
<a id="af2d5fffe1213a826543171b4330af099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d5fffe1213a826543171b4330af099">&#9670;&nbsp;</a></span>getVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to the variable that defines certain types of expressions. </p>
<dl class="section return"><dt>Returns</dt><dd><b>variable</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classPolynomial.html#ad1dc7c48eedf94ffe156fd0e0624bb35">Polynomial</a>.</p>

</div>
</div>
<a id="a5a7170bc22902a3964584ae8994a84b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7170bc22902a3964584ae8994a84b4">&#9670;&nbsp;</a></span>getVectorArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt; &amp; getVectorArgument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to get the entire std::vector of arguments of the expression. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must not be called for building blocks, one must check first that the expression has arguments. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The std::vector of argument. </dd></dl>

<p>Reimplemented in <a class="el" href="classITerm.html#aacdc998afa6abe3cd8b2f230005b3950">ITerm</a>, <a class="el" href="classAbstractMultiFunc.html#aacdc998afa6abe3cd8b2f230005b3950">AbstractMultiFunc</a>, and <a class="el" href="classAbstractVectorial.html#aacdc998afa6abe3cd8b2f230005b3950">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a3920c1dff045e546ccc0286c2c2677e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3920c1dff045e546ccc0286c2c2677e8">&#9670;&nbsp;</a></span>getVectorialModulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getVectorialModulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Vectorial modulus of the <b>Vectorial</b> object, that is defined here as the squared root of the sum of element squared. Example: {A_{11}^2+A_{12}^2+}. </p>
<dl class="section return"><dt>Returns</dt><dd>The vectorial modulus of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#a8a7a92b35a50908f79ded8dd5522150f">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a49620ec470e935ce2c770981e4f338dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49620ec470e935ce2c770981e4f338dc">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>side</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an expression in a sum or a product. </p>
<p>Allows to insert an element in a sum or product without comparing all existing terms. This saves time when inserting element by element. The <b>side</b> parameter allows to insert to the left (side = 0) or to the right (side = 1) in products (useful when considering non commutating expressions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to insert. </td></tr>
    <tr><td class="paramname">side</td><td>Side of insertion for <a class="el" href="classTimes.html" title="Handles a product, function of multiple arguments. ">Times</a> expressions. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classTimes.html#aa32280c01018eba348c41392e23a089f">Times</a>, and <a class="el" href="classPlus.html#aa32280c01018eba348c41392e23a089f">Plus</a>.</p>

</div>
</div>
<a id="aa7bec3a80614b4fa4352577eb0528b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bec3a80614b4fa4352577eb0528b79">&#9670;&nbsp;</a></span>inverseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> inverseMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the inverse of a 2D square matrix. The applied method is: A^{-1} = 1/det(A)*Com(A)^T. </p>
<dl class="section return"><dt>Returns</dt><dd>A^{-1} for a matrix (2D) A if det(A) != 0. </dd>
<dd>
0 else </dd></dl>

<p>Reimplemented in <a class="el" href="classMatrix.html#aac42a297369ad16861d383d1173d5360">Matrix</a>.</p>

</div>
</div>
<a id="a134526a9e561b38741398c32f76c91b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134526a9e561b38741398c32f76c91b8">&#9670;&nbsp;</a></span>isBuildingBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isBuildingBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if the expression is a Building Block or not. </p>
<p>Building blocks are derived classes that cannot contain further expressions, i.e. expressions that are the leafs of the recursive tree reprensent mathematical expressions: numerical or pure literal objects (variable, constant etc). </p><dl class="section return"><dt>Returns</dt><dd><b>True</b> if <em>*this</em> is a Building Block. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractBuildingBlock.html#a862925e0c7374e063c14c9bf2104340c">AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="acf82f9b2937375c7b1cf3dccb3df3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf82f9b2937375c7b1cf3dccb3df3312">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells for a <a class="el" href="classDerivative.html" title="Handles the exponentiation of one Abstract wrt another. ">Derivative</a> or an Integral if the argument is empty i.e. if the object must apply on the next argument encountered on the right. </p>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the <a class="el" href="classDerivative.html" title="Handles the exponentiation of one Abstract wrt another. ">Derivative</a> or Integral awaits an argument. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classDerivative.html#a88bcd3a5f8928c4f55d26a417a0bb447">Derivative</a>.</p>

</div>
</div>
<a id="aa3672834c6627f73acc4219096301ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3672834c6627f73acc4219096301ada">&#9670;&nbsp;</a></span>isIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isIndexed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is indexed. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractMultiFunc.html#a190a9f0cd68215273e87b627c878baa2">AbstractMultiFunc</a>, <a class="el" href="classPolynomial.html#a190a9f0cd68215273e87b627c878baa2">Polynomial</a>, <a class="el" href="classAbstractDuoFunc.html#a190a9f0cd68215273e87b627c878baa2">AbstractDuoFunc</a>, and <a class="el" href="classAbstractFunc.html#a190a9f0cd68215273e87b627c878baa2">AbstractFunc</a>.</p>

</div>
</div>
<a id="a8f96f613f3813778606654fc57b9256b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f96f613f3813778606654fc57b9256b">&#9670;&nbsp;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if the expression is an integer. Either an <a class="el" href="classInteger.html" title="Handle numbers in expr. ">Integer</a> object directly, or a <a class="el" href="classDouble.html" title="Handle numbers in expr. ">Double</a> that has an integer value. </p>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <em>*this</em> is an <a class="el" href="classInteger.html" title="Handle numbers in expr. ">Integer</a> or a <a class="el" href="classDouble.html" title="Handle numbers in expr. ">Double</a> with integer value. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classDouble.html#a251299017ba90f23114a3dc9b4814111">Double</a>, and <a class="el" href="classInteger.html#a251299017ba90f23114a3dc9b4814111">Integer</a>.</p>

</div>
</div>
<a id="af5fb27a847c4aceb353cce8183df51be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fb27a847c4aceb353cce8183df51be">&#9670;&nbsp;</a></span>isPolynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int isPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the expression is a mononomial term in <b>expr</b>, i.e. a term of the form C*expr^n with C independent of expr, n integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><a class="el" href="classVariable.html" title="Handle an object with a name and a value. ">Variable</a> of the supposed mononomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The order of the exponent if there is one (n in the example). </dd>
<dd>
-1 else. </dd></dl>

<p>Reimplemented in <a class="el" href="classPow.html#a2026130e23bb5b4ee6ee7ae2b1521a26">Pow</a>, <a class="el" href="classFraction.html#a2026130e23bb5b4ee6ee7ae2b1521a26">Fraction</a>, <a class="el" href="classTimes.html#a2026130e23bb5b4ee6ee7ae2b1521a26">Times</a>, <a class="el" href="classAbstractMultiFunc.html#a2026130e23bb5b4ee6ee7ae2b1521a26">AbstractMultiFunc</a>, <a class="el" href="classAbstractDuoFunc.html#a2026130e23bb5b4ee6ee7ae2b1521a26">AbstractDuoFunc</a>, and <a class="el" href="classAbstractFunc.html#a2026130e23bb5b4ee6ee7ae2b1521a26">AbstractFunc</a>.</p>

</div>
</div>
<a id="af5e8162a13d141bbc3fe41b37f7c98e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e8162a13d141bbc3fe41b37f7c98e2">&#9670;&nbsp;</a></span>matchShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool matchShape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In the case of a vectorial-type expression, this function checks if the shape of expr matches itself. </p>
<p>If <b>exact</b> is true, the function search an exact match i.e. either the two shapes are exactly equal or one of the two objects is a scalar. If <b>exact</b> is false, this function only search for a possible dot product between the two expressions, and see if the last axis of <b>*this</b> matches the first of <b>expr</b> (or if one of the two objects is scalar also). Then, a product  _k (*this)[i,j,...,k]*expr[k,l,m,...] is possible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression of which we compare the shape. </td></tr>
    <tr><td class="paramname">exact</td><td>Boolean than specifies if we need an exact match or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two shapes correspond. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#a41679a5ac7ec7a7b338d7a240fa9a0ec">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a4bc5594d9ea621809a36f8f71cfbcc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc5594d9ea621809a36f8f71cfbcc8a">&#9670;&nbsp;</a></span>multiplication_own()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> multiplication_own </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains implementation of special multiplication for Numerical- and Vectorial-types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Right operrand of the product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two operands. </dd></dl>

<p>Reimplemented in <a class="el" href="classCFraction.html#a417cab565d5c641e28ac86785eee7463">CFraction</a>, <a class="el" href="classDouble.html#a417cab565d5c641e28ac86785eee7463">Double</a>, <a class="el" href="classPolynomial.html#a417cab565d5c641e28ac86785eee7463">Polynomial</a>, <a class="el" href="classInteger.html#a417cab565d5c641e28ac86785eee7463">Integer</a>, and <a class="el" href="classAbstractVectorial.html#a417cab565d5c641e28ac86785eee7463">AbstractVectorial</a>.</p>

</div>
</div>
<a id="ad3c15e5e29f3e15ade703b1135efd20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c15e5e29f3e15ade703b1135efd20f">&#9670;&nbsp;</a></span>operator &=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the simplicity of the expression to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><b>Expression</b> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>False</b> if the two expression have the same simplicity. </dd>
<dd>
<b>True</b> else. </dd></dl>

</div>
</div>
<a id="a4e51647ab1a6ab6c1151d3b1fe00575c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e51647ab1a6ab6c1151d3b1fe00575c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t_value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>False</b> if the expression is valued and is equal to t_value. </dd>
<dd>
<b>True</b> else. </dd></dl>

</div>
</div>
<a id="a2d5d7caab7b39ed1a425456e09fe10d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5d7caab7b39ed1a425456e09fe10d8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>False</b> if the expression is valued and is equal to t_value. </dd>
<dd>
<b>True</b> else. </dd></dl>

</div>
</div>
<a id="abd82f421ad221566224e1ddf22978b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd82f421ad221566224e1ddf22978b04">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Compares</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two Abstracts are the same (or have the same name). </dd>
<dd>
True else. </dd></dl>

</div>
</div>
<a id="afc57fa894a78c5daebc8bc3ef113740f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc57fa894a78c5daebc8bc3ef113740f">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the simplicity of the expression to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><b>Expression</b> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>False</b> if <b>expr</b> is simpler or equivalent. </dd>
<dd>
<b>True</b> else. </dd></dl>

<p>Implemented in <a class="el" href="classImaginary.html#a26d388751fbd94c687b09811dd552a65">Imaginary</a>, <a class="el" href="classCFactorial.html#a26d388751fbd94c687b09811dd552a65">CFactorial</a>, <a class="el" href="classAngle.html#a26d388751fbd94c687b09811dd552a65">Angle</a>, <a class="el" href="classDerivative.html#a26d388751fbd94c687b09811dd552a65">Derivative</a>, <a class="el" href="classVariable.html#a26d388751fbd94c687b09811dd552a65">Variable</a>, <a class="el" href="classPow.html#a26d388751fbd94c687b09811dd552a65">Pow</a>, <a class="el" href="classConstant.html#a26d388751fbd94c687b09811dd552a65">Constant</a>, <a class="el" href="classITerm.html#a26d388751fbd94c687b09811dd552a65">ITerm</a>, <a class="el" href="classITensor.html#a26d388751fbd94c687b09811dd552a65">ITensor</a>, <a class="el" href="classFraction.html#a26d388751fbd94c687b09811dd552a65">Fraction</a>, <a class="el" href="classCFraction.html#a26d388751fbd94c687b09811dd552a65">CFraction</a>, <a class="el" href="classTimes.html#a26d388751fbd94c687b09811dd552a65">Times</a>, <a class="el" href="classDouble.html#a26d388751fbd94c687b09811dd552a65">Double</a>, <a class="el" href="classHighDTensor.html#a26d388751fbd94c687b09811dd552a65">HighDTensor</a>, <a class="el" href="classPolynomial.html#a26d388751fbd94c687b09811dd552a65">Polynomial</a>, <a class="el" href="classMatrix.html#a26d388751fbd94c687b09811dd552a65">Matrix</a>, <a class="el" href="classInteger.html#a26d388751fbd94c687b09811dd552a65">Integer</a>, <a class="el" href="classVector.html#a26d388751fbd94c687b09811dd552a65">Vector</a>, <a class="el" href="classPlus.html#a26d388751fbd94c687b09811dd552a65">Plus</a>, and <a class="el" href="classAbstractFunc.html#a26d388751fbd94c687b09811dd552a65">AbstractFunc</a>.</p>

</div>
</div>
<a id="a3ba6b588c907bb15f8daa152655e58e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba6b588c907bb15f8daa152655e58e5">&#9670;&nbsp;</a></span>operator<=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the simplicity of the expression to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><b>Expression</b> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>False</b> if <b>expr</b> is simpler. </dd>
<dd>
<b>True</b> else. </dd></dl>

</div>
</div>
<a id="a45e27d5fe7cf8a4db9e837a024b8e73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e27d5fe7cf8a4db9e837a024b8e73e">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operator= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to the <a class="el" href="classAbstract.html#afbf2751548904140aa7aa4a1e8e59346" title="Sets the value if there is one (for Numerical and Literal valued). ">setValue()</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_value</td><td>The new value of the expression. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classVariable.html#af49c10e9ec988ff879b8e50bfa2585fc">Variable</a>, <a class="el" href="classConstant.html#af49c10e9ec988ff879b8e50bfa2585fc">Constant</a>, <a class="el" href="classCFraction.html#af49c10e9ec988ff879b8e50bfa2585fc">CFraction</a>, and <a class="el" href="classDouble.html#af49c10e9ec988ff879b8e50bfa2585fc">Double</a>.</p>

</div>
</div>
<a id="a9687663de691e5ce2750370e0c6ab295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9687663de691e5ce2750370e0c6ab295">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t_value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is valued and is equal to t_value. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="a8e08758ab4a9422c56b18af734f9ed18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e08758ab4a9422c56b18af734f9ed18">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is valued and is equal to t_value. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="a6659bcfd9c94a8b2605027ca77d2f8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6659bcfd9c94a8b2605027ca77d2f8fe">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Compares</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another. </p>
<p>Here if two Abstracts have the same name, the function will return <b>true</b> even if they are <b>not</b> <b>mathematically</b> <b>equal</b>. So beware not to name different things the same way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two Abstracts are the same (or have the same name). </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Implemented in <a class="el" href="classImaginary.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Imaginary</a>, <a class="el" href="classCFactorial.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">CFactorial</a>, <a class="el" href="classAngle.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Angle</a>, <a class="el" href="classDerivative.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Derivative</a>, <a class="el" href="classVariable.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Variable</a>, <a class="el" href="classPow.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Pow</a>, <a class="el" href="classConstant.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Constant</a>, <a class="el" href="classITerm.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">ITerm</a>, <a class="el" href="classITensor.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">ITensor</a>, <a class="el" href="classFraction.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Fraction</a>, <a class="el" href="classCFraction.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">CFraction</a>, <a class="el" href="classTimes.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Times</a>, <a class="el" href="classAbstractMultiFunc.html#a9a2b25eb515b6b4e005efe840e145f2c">AbstractMultiFunc</a>, <a class="el" href="classDouble.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Double</a>, <a class="el" href="classPolynomial.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Polynomial</a>, <a class="el" href="classAbstractDuoFunc.html#a9a2b25eb515b6b4e005efe840e145f2c">AbstractDuoFunc</a>, <a class="el" href="classInteger.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Integer</a>, <a class="el" href="classAbstractVectorial.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">AbstractVectorial</a>, <a class="el" href="classPlus.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">Plus</a>, and <a class="el" href="classAbstractFunc.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">AbstractFunc</a>.</p>

</div>
</div>
<a id="af26068fd48ccc64453283e32c552f9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26068fd48ccc64453283e32c552f9e5">&#9670;&nbsp;</a></span>operator>()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the simplicity of the expression to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><b>Expression</b> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>expr</b> is simpler. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Implemented in <a class="el" href="classImaginary.html#a54ab0ab35f14438145a16f887b060de8">Imaginary</a>, <a class="el" href="classCFactorial.html#a54ab0ab35f14438145a16f887b060de8">CFactorial</a>, <a class="el" href="classAngle.html#a54ab0ab35f14438145a16f887b060de8">Angle</a>, <a class="el" href="classDerivative.html#a54ab0ab35f14438145a16f887b060de8">Derivative</a>, <a class="el" href="classVariable.html#a54ab0ab35f14438145a16f887b060de8">Variable</a>, <a class="el" href="classPow.html#a54ab0ab35f14438145a16f887b060de8">Pow</a>, <a class="el" href="classConstant.html#a54ab0ab35f14438145a16f887b060de8">Constant</a>, <a class="el" href="classITerm.html#a54ab0ab35f14438145a16f887b060de8">ITerm</a>, <a class="el" href="classITensor.html#a54ab0ab35f14438145a16f887b060de8">ITensor</a>, <a class="el" href="classFraction.html#a54ab0ab35f14438145a16f887b060de8">Fraction</a>, <a class="el" href="classCFraction.html#a54ab0ab35f14438145a16f887b060de8">CFraction</a>, <a class="el" href="classTimes.html#a54ab0ab35f14438145a16f887b060de8">Times</a>, <a class="el" href="classDouble.html#a54ab0ab35f14438145a16f887b060de8">Double</a>, <a class="el" href="classHighDTensor.html#a54ab0ab35f14438145a16f887b060de8">HighDTensor</a>, <a class="el" href="classPolynomial.html#a54ab0ab35f14438145a16f887b060de8">Polynomial</a>, <a class="el" href="classMatrix.html#a54ab0ab35f14438145a16f887b060de8">Matrix</a>, <a class="el" href="classInteger.html#a54ab0ab35f14438145a16f887b060de8">Integer</a>, <a class="el" href="classVector.html#a54ab0ab35f14438145a16f887b060de8">Vector</a>, <a class="el" href="classPlus.html#a54ab0ab35f14438145a16f887b060de8">Plus</a>, and <a class="el" href="classAbstractFunc.html#a54ab0ab35f14438145a16f887b060de8">AbstractFunc</a>.</p>

</div>
</div>
<a id="af94e9a1081c5b78f63fa05ea6e379d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94e9a1081c5b78f63fa05ea6e379d6f">&#9670;&nbsp;</a></span>operator>=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the simplicity of the expression to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><b>Expression</b> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>expr</b> is simpler or equivalent. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="a0cdf1c2cd531cc0385c5879a83ee15f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdf1c2cd531cc0385c5879a83ee15f6">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access operator for multi-argument expressions, equivalent to the function <a class="el" href="classAbstract.html#a75c8c199caec4d49c81b330954228b72" title="Sets the argument at position iArg (default=0). ">setArgument()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iArg</td><td><a class="el" href="classIndex.html">Index</a> of the argument to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>argument</b>[iArg]. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#ac5b51c602067e2b2e1db0c6b797e96d6">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a13cfb786cf54b23696ccdb0a9dd9d6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cfb786cf54b23696ccdb0a9dd9d6ad">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the simplicity of the expression to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><b>Expression</b> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two expression have the same simplicity. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="ae9f5a37ad523ec663a61d07def420820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f5a37ad523ec663a61d07def420820">&#9670;&nbsp;</a></span>permut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int permut </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to permut indices at place <b>i1</b> and <b>i2</b>. If those two indices have a symmetry property, indices are swaped and the symmetry is returned. Else the fnuction does nothing and returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i1</td><td>Position of the first index. </td></tr>
    <tr><td class="paramname">i2</td><td>Position of the second index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the permutation **(i1,i2) is symmetric**. </dd>
<dd>
-1 if the permutation **(i1,i2) is anti-symmetric**. </dd>
<dd>
0 else (and do not permut the two indices). </dd></dl>

</div>
</div>
<a id="a0580f5b543391148404278629c495668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0580f5b543391148404278629c495668">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void print </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays the abstract in standard output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Tells if the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> is printed alone (default) or in another expr. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classFactorial.html#abd9f12af3b52f041754d10bc7f106a96">Factorial</a>, <a class="el" href="classATanh.html#abd9f12af3b52f041754d10bc7f106a96">ATanh</a>, <a class="el" href="classASinh.html#abd9f12af3b52f041754d10bc7f106a96">ASinh</a>, <a class="el" href="classACosh.html#abd9f12af3b52f041754d10bc7f106a96">ACosh</a>, <a class="el" href="classTanh.html#abd9f12af3b52f041754d10bc7f106a96">Tanh</a>, <a class="el" href="classSinh.html#abd9f12af3b52f041754d10bc7f106a96">Sinh</a>, <a class="el" href="classImaginary.html#abd9f12af3b52f041754d10bc7f106a96">Imaginary</a>, <a class="el" href="classCosh.html#abd9f12af3b52f041754d10bc7f106a96">Cosh</a>, <a class="el" href="classCFactorial.html#abd9f12af3b52f041754d10bc7f106a96">CFactorial</a>, <a class="el" href="classAngle.html#abd9f12af3b52f041754d10bc7f106a96">Angle</a>, <a class="el" href="classDerivative.html#abd9f12af3b52f041754d10bc7f106a96">Derivative</a>, <a class="el" href="classVariable.html#abd9f12af3b52f041754d10bc7f106a96">Variable</a>, <a class="el" href="classATan.html#abd9f12af3b52f041754d10bc7f106a96">ATan</a>, <a class="el" href="classASin.html#abd9f12af3b52f041754d10bc7f106a96">ASin</a>, <a class="el" href="classPow.html#abd9f12af3b52f041754d10bc7f106a96">Pow</a>, <a class="el" href="classITerm.html#abd9f12af3b52f041754d10bc7f106a96">ITerm</a>, <a class="el" href="classConstant.html#abd9f12af3b52f041754d10bc7f106a96">Constant</a>, <a class="el" href="classACos.html#abd9f12af3b52f041754d10bc7f106a96">ACos</a>, <a class="el" href="classITensor.html#abd9f12af3b52f041754d10bc7f106a96">ITensor</a>, <a class="el" href="classFraction.html#abd9f12af3b52f041754d10bc7f106a96">Fraction</a>, <a class="el" href="classTan.html#abd9f12af3b52f041754d10bc7f106a96">Tan</a>, <a class="el" href="classCFraction.html#abd9f12af3b52f041754d10bc7f106a96">CFraction</a>, <a class="el" href="classSin.html#abd9f12af3b52f041754d10bc7f106a96">Sin</a>, <a class="el" href="classTimes.html#abd9f12af3b52f041754d10bc7f106a96">Times</a>, <a class="el" href="classCos.html#abd9f12af3b52f041754d10bc7f106a96">Cos</a>, <a class="el" href="classDouble.html#abd9f12af3b52f041754d10bc7f106a96">Double</a>, <a class="el" href="classLog.html#abd9f12af3b52f041754d10bc7f106a96">Log</a>, <a class="el" href="classPolynomial.html#abd9f12af3b52f041754d10bc7f106a96">Polynomial</a>, <a class="el" href="classInteger.html#abd9f12af3b52f041754d10bc7f106a96">Integer</a>, <a class="el" href="classExp.html#abd9f12af3b52f041754d10bc7f106a96">Exp</a>, <a class="el" href="classPlus.html#abd9f12af3b52f041754d10bc7f106a96">Plus</a>, <a class="el" href="classAbs.html#abd9f12af3b52f041754d10bc7f106a96">Abs</a>, and <a class="el" href="classAbstractVectorial.html#abd9f12af3b52f041754d10bc7f106a96">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a8f86250bd135d34203d40020a6c9b56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f86250bd135d34203d40020a6c9b56f">&#9670;&nbsp;</a></span>printExplicit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printExplicit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays explicitely the expression, with types of each component. This function is only used for debug. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Mode of printing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af21ac36bebac371e07ca725f91c9a21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21ac36bebac371e07ca725f91c9a21c">&#9670;&nbsp;</a></span>printLaTeX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string printLaTeX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a LaTeX output for the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Tells if the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> is printed alone (default) or in another expr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string corresponding to the LaTeX output. </dd></dl>

<p>Reimplemented in <a class="el" href="classFactorial.html#a8086e83f45a0d609ebe40a6f0a269e88">Factorial</a>, <a class="el" href="classATanh.html#a8086e83f45a0d609ebe40a6f0a269e88">ATanh</a>, <a class="el" href="classASinh.html#a8086e83f45a0d609ebe40a6f0a269e88">ASinh</a>, <a class="el" href="classACosh.html#a8086e83f45a0d609ebe40a6f0a269e88">ACosh</a>, <a class="el" href="classTanh.html#a8086e83f45a0d609ebe40a6f0a269e88">Tanh</a>, <a class="el" href="classSinh.html#a8086e83f45a0d609ebe40a6f0a269e88">Sinh</a>, <a class="el" href="classImaginary.html#a8086e83f45a0d609ebe40a6f0a269e88">Imaginary</a>, <a class="el" href="classCosh.html#a8086e83f45a0d609ebe40a6f0a269e88">Cosh</a>, <a class="el" href="classCFactorial.html#a8086e83f45a0d609ebe40a6f0a269e88">CFactorial</a>, <a class="el" href="classAngle.html#a8086e83f45a0d609ebe40a6f0a269e88">Angle</a>, <a class="el" href="classDerivative.html#a8086e83f45a0d609ebe40a6f0a269e88">Derivative</a>, <a class="el" href="classVariable.html#a8086e83f45a0d609ebe40a6f0a269e88">Variable</a>, <a class="el" href="classATan.html#a8086e83f45a0d609ebe40a6f0a269e88">ATan</a>, <a class="el" href="classASin.html#a8086e83f45a0d609ebe40a6f0a269e88">ASin</a>, <a class="el" href="classPow.html#a8086e83f45a0d609ebe40a6f0a269e88">Pow</a>, <a class="el" href="classITerm.html#a8086e83f45a0d609ebe40a6f0a269e88">ITerm</a>, <a class="el" href="classConstant.html#a8086e83f45a0d609ebe40a6f0a269e88">Constant</a>, <a class="el" href="classACos.html#a8086e83f45a0d609ebe40a6f0a269e88">ACos</a>, <a class="el" href="classITensor.html#a8086e83f45a0d609ebe40a6f0a269e88">ITensor</a>, <a class="el" href="classFraction.html#a8086e83f45a0d609ebe40a6f0a269e88">Fraction</a>, <a class="el" href="classTan.html#a8086e83f45a0d609ebe40a6f0a269e88">Tan</a>, <a class="el" href="classCFraction.html#a8086e83f45a0d609ebe40a6f0a269e88">CFraction</a>, <a class="el" href="classSin.html#a8086e83f45a0d609ebe40a6f0a269e88">Sin</a>, <a class="el" href="classTimes.html#a8086e83f45a0d609ebe40a6f0a269e88">Times</a>, <a class="el" href="classCos.html#a8086e83f45a0d609ebe40a6f0a269e88">Cos</a>, <a class="el" href="classDouble.html#a8086e83f45a0d609ebe40a6f0a269e88">Double</a>, <a class="el" href="classLog.html#a8086e83f45a0d609ebe40a6f0a269e88">Log</a>, <a class="el" href="classPolynomial.html#a8086e83f45a0d609ebe40a6f0a269e88">Polynomial</a>, <a class="el" href="classInteger.html#a8086e83f45a0d609ebe40a6f0a269e88">Integer</a>, <a class="el" href="classExp.html#a8086e83f45a0d609ebe40a6f0a269e88">Exp</a>, <a class="el" href="classPlus.html#a8086e83f45a0d609ebe40a6f0a269e88">Plus</a>, <a class="el" href="classAbs.html#a8086e83f45a0d609ebe40a6f0a269e88">Abs</a>, and <a class="el" href="classAbstractVectorial.html#a8086e83f45a0d609ebe40a6f0a269e88">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a75c8c199caec4d49c81b330954228b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c8c199caec4d49c81b330954228b72">&#9670;&nbsp;</a></span>setArgument() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iArg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the argument at position <b>iArg</b> (default=0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression that replaces the argument. </td></tr>
    <tr><td class="paramname">iArg</td><td>the position of the argument to change. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classAbstractMultiFunc.html#a037ea9c6197d0b07a5c73116c2d288ea">AbstractMultiFunc</a>, <a class="el" href="classAbstractDuoFunc.html#a037ea9c6197d0b07a5c73116c2d288ea">AbstractDuoFunc</a>, <a class="el" href="classAbstractFunc.html#a037ea9c6197d0b07a5c73116c2d288ea">AbstractFunc</a>, and <a class="el" href="classAbstractVectorial.html#a41a215382d81df0b37903a55dd56d485">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a61f4a9411974d0b2f61a004c79139a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f4a9411974d0b2f61a004c79139a64">&#9670;&nbsp;</a></span>setArgument() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression that replaces the argument. </td></tr>
    <tr><td class="paramname">indices</td><td>An intializer_list containing the series of indices corresponding to the argument to replace. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#a55833e40303f215acf7641c47318bb92">AbstractVectorial</a>.</p>

</div>
</div>
<a id="aaff36101861ab91916f2c617a15f7687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff36101861ab91916f2c617a15f7687">&#9670;&nbsp;</a></span>setArgument() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression that replaces the argument. </td></tr>
    <tr><td class="paramname">indices</td><td>An std::vector containing the series of indices corresponding to the argument to replace. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#a94121f60b12f43e773d162bc1a4f2989">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a128daf984905d30e5c966492001c23b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128daf984905d30e5c966492001c23b4">&#9670;&nbsp;</a></span>setCommutable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setCommutable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t_commutable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the abstract to commute or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_commutable</td><td>Must be <b>true</b> if the abstract can commute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bd2d23b77d3719cbe2db2f27c4ad9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd2d23b77d3719cbe2db2f27c4ad9c9">&#9670;&nbsp;</a></span>setIndexStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setIndexStructure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndex.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>t_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the index structure of the object, that must be an <b>Indicial</b> expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_index</td><td>A std::vector of <a class="el" href="classIndex.html">Index</a> which takes the place of the structure index. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classITensor.html#a301106d98a953a2cffe69c774d6933e3">ITensor</a>.</p>

</div>
</div>
<a id="ad305ee5e54d468c64c6b46658aa210e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad305ee5e54d468c64c6b46658aa210e0">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>t_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the name of the abstract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_name</td><td>Replaces name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab76aaf6a94588273e3f92cf1980cf7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76aaf6a94588273e3f92cf1980cf7ec">&#9670;&nbsp;</a></span>setVectorArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setVectorArgument </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>t_argument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the entire std::vector of argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_argument</td><td>std::vector of expressions to copy. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classAbstractMultiFunc.html#aa91d8c931bcc6bd05116a7001df7c158">AbstractMultiFunc</a>, and <a class="el" href="classAbstractVectorial.html#aa91d8c931bcc6bd05116a7001df7c158">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a50ac62534de5f3fd86899a9c2edb8f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ac62534de5f3fd86899a9c2edb8f43">&#9670;&nbsp;</a></span>suppressTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> suppressTerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a factor from an expr, that must have been determined before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>Expression to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expr in which <b>factor</b> has been removed </dd></dl>

<p>Reimplemented in <a class="el" href="classPow.html#a5ff960d2a10c2ad34917e2238dcfde30">Pow</a>, <a class="el" href="classFraction.html#a5ff960d2a10c2ad34917e2238dcfde30">Fraction</a>, and <a class="el" href="classTimes.html#a5ff960d2a10c2ad34917e2238dcfde30">Times</a>.</p>

</div>
</div>
<a id="a8269986297fc4b551de89d6d3900ca36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8269986297fc4b551de89d6d3900ca36">&#9670;&nbsp;</a></span>symmetrise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> symmetrise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the symmetrization of a 2D matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>1/2*(A + A^T) for a matrix (2D) A. </dd></dl>

<p>Reimplemented in <a class="el" href="classMatrix.html#a727124693b2336410962a8c2ed907d36">Matrix</a>.</p>

</div>
</div>
<a id="a250b633a570e586433cea97c05fcc5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250b633a570e586433cea97c05fcc5fe">&#9670;&nbsp;</a></span>tensor_dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> tensor_dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tensor_dot of two <b>Vectorial</b> expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The right operand of the tensor_dot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor dot of <b>*this</b> and <b>expr</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#a0adf32913aa9251d725b9e8acaf5d9ee">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a31ebeb9355bb8491aeb909094ef1a946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ebeb9355bb8491aeb909094ef1a946">&#9670;&nbsp;</a></span>trace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><em>i A</em>{ii} for a square matrix A. </dd>
<dd>
A for a scalar A. </dd>
<dd>
0 else. </dd></dl>

<p>Reimplemented in <a class="el" href="classMatrix.html#a44da233e3914a4d5a0eb1d310ff43f60">Matrix</a>.</p>

</div>
</div>
<a id="a12d7558a06855e805ab2b347c89fbab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d7558a06855e805ab2b347c89fbab4">&#9670;&nbsp;</a></span>trace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> trace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the trace over the axis <b>axis1</b> and <b>axis2</b> of a tensor. <b>axis1</b> and <b>axis2</b> can be the same, in which case the trace just corresponds to the sum over this particular axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis1</td><td>First axis to contract. </td></tr>
    <tr><td class="paramname">axis2</td><td>Second axis to contract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the trace over axis <b>axis1</b> and <b>axis2</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractVectorial.html#ade105c7b96ac33d550011007c554b318">AbstractVectorial</a>.</p>

</div>
</div>
<a id="a23c28051b0366bafc6dcb0704d765fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c28051b0366bafc6dcb0704d765fe9">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the transpose of a 2D matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>A^T for a matrix (2D) A. </dd></dl>

<p>Reimplemented in <a class="el" href="classMatrix.html#ab00c3c8f79df6685908055355a90856f">Matrix</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a98b736117ed72bc3d8bc6813c97ca850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b736117ed72bc3d8bc6813c97ca850">&#9670;&nbsp;</a></span>commutable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool commutable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if the object <b>commutes</b> with all other objects. </p>

</div>
</div>
<a id="a5526f40b4ddcf23b599388283b318a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5526f40b4ddcf23b599388283b318a13">&#9670;&nbsp;</a></span>indexed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool indexed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tells if the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> is indexed (A_ij, A_ij + B_ji etc). </p>

</div>
</div>
<a id="a9b45b3e13bd9167aab02e17e08916231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b45b3e13bd9167aab02e17e08916231">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Name that will define the object, <b>crucial</b> <b>in</b> <b>comparisons</b>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="abstract_8h_source.html">abstract.h</a></li>
<li>src/abstract.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
