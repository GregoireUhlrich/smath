<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Symbolic Mathematics Library (SML): AbstractVectorial Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Symbolic Mathematics Library (SML)
   </div>
   <div id="projectbrief">Symbolic calculation package for quantum field theory</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">AbstractVectorial Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for AbstractVectorial:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classAbstractVectorial__inherit__graph.svg" width="278" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abd9f12af3b52f041754d10bc7f106a96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#abd9f12af3b52f041754d10bc7f106a96">print</a> (int mode=0) const override</td></tr>
<tr class="memdesc:abd9f12af3b52f041754d10bc7f106a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the abstract in standard output.  <a href="#abd9f12af3b52f041754d10bc7f106a96">More...</a><br /></td></tr>
<tr class="separator:abd9f12af3b52f041754d10bc7f106a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8086e83f45a0d609ebe40a6f0a269e88"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a8086e83f45a0d609ebe40a6f0a269e88">printLaTeX</a> (int mode=0) const override</td></tr>
<tr class="memdesc:a8086e83f45a0d609ebe40a6f0a269e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a LaTeX output for the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a8086e83f45a0d609ebe40a6f0a269e88">More...</a><br /></td></tr>
<tr class="separator:a8086e83f45a0d609ebe40a6f0a269e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9371625b49860dbbd2299b5de7043fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a9371625b49860dbbd2299b5de7043fe0">evaluate</a> () override</td></tr>
<tr class="memdesc:a9371625b49860dbbd2299b5de7043fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a9371625b49860dbbd2299b5de7043fe0">More...</a><br /></td></tr>
<tr class="separator:a9371625b49860dbbd2299b5de7043fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611142e741518fc0745828678d1dfd7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a611142e741518fc0745828678d1dfd7f">getDim</a> () const override</td></tr>
<tr class="memdesc:a611142e741518fc0745828678d1dfd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>dimension</b> of the object.  <a href="#a611142e741518fc0745828678d1dfd7f">More...</a><br /></td></tr>
<tr class="separator:a611142e741518fc0745828678d1dfd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4c472299ada58b0101d4e70c574105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a8e2e97c94555dae36453ba3c507db79e">smType::PrimaryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a6e4c472299ada58b0101d4e70c574105">getPrimaryType</a> () const override</td></tr>
<tr class="memdesc:a6e4c472299ada58b0101d4e70c574105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>primary</b> <b>type</b> of <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a6e4c472299ada58b0101d4e70c574105">More...</a><br /></td></tr>
<tr class="separator:a6e4c472299ada58b0101d4e70c574105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543e3e72f78bf20e1d63630404566262"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a543e3e72f78bf20e1d63630404566262">getNArgs</a> (int axis=0) const override</td></tr>
<tr class="memdesc:a543e3e72f78bf20e1d63630404566262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of arguments of the expression. If the expression is a building block (<a class="el" href="classAbstractBuildingBlock.html" title="Abstract class from which derive all building blocks of exprs, i.e. objects not function of further e...">AbstractBuildingBlock</a>), this function returns 0.  <a href="#a543e3e72f78bf20e1d63630404566262">More...</a><br /></td></tr>
<tr class="separator:a543e3e72f78bf20e1d63630404566262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7464cab53ca461aa7a8892b0dae42ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a1fc3ae6bd5c6a80e9b81b27fc7b7a11a">iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#ad7464cab53ca461aa7a8892b0dae42ad">begin</a> () override</td></tr>
<tr class="separator:ad7464cab53ca461aa7a8892b0dae42ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6bf18a6497121de6a24684f727a88d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#ac50bb217e67a9c51fa2b4322f56ec1a4">const_iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a7a6bf18a6497121de6a24684f727a88d">begin</a> () const override</td></tr>
<tr class="separator:a7a6bf18a6497121de6a24684f727a88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02492275aeabe839fa74aa7952e7fad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a1fc3ae6bd5c6a80e9b81b27fc7b7a11a">iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#ac02492275aeabe839fa74aa7952e7fad">end</a> () override</td></tr>
<tr class="separator:ac02492275aeabe839fa74aa7952e7fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd533082e1ba5a159f746c26828f132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#ac50bb217e67a9c51fa2b4322f56ec1a4">const_iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#acbd533082e1ba5a159f746c26828f132">end</a> () const override</td></tr>
<tr class="separator:acbd533082e1ba5a159f746c26828f132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61b5bdbc1b2651da335257b057e7491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#ae61b5bdbc1b2651da335257b057e7491">getArgument</a> (int iArg=0) const override</td></tr>
<tr class="separator:ae61b5bdbc1b2651da335257b057e7491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9465ac47b8a768dec6e08daa1376777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#ad9465ac47b8a768dec6e08daa1376777">getArgument</a> (const std::initializer_list&lt; int &gt; &amp;indices) const override</td></tr>
<tr class="memdesc:ad9465ac47b8a768dec6e08daa1376777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension.  <a href="#ad9465ac47b8a768dec6e08daa1376777">More...</a><br /></td></tr>
<tr class="separator:ad9465ac47b8a768dec6e08daa1376777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04856666aedc3cea3052858844947d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#ab04856666aedc3cea3052858844947d7">getArgument</a> (const std::vector&lt; int &gt; &amp;indices) const override</td></tr>
<tr class="memdesc:ab04856666aedc3cea3052858844947d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension.  <a href="#ab04856666aedc3cea3052858844947d7">More...</a><br /></td></tr>
<tr class="separator:ab04856666aedc3cea3052858844947d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdc998afa6abe3cd8b2f230005b3950"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#aacdc998afa6abe3cd8b2f230005b3950">getVectorArgument</a> () const override</td></tr>
<tr class="memdesc:aacdc998afa6abe3cd8b2f230005b3950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get the entire std::vector of arguments of the expression.  <a href="#aacdc998afa6abe3cd8b2f230005b3950">More...</a><br /></td></tr>
<tr class="separator:aacdc998afa6abe3cd8b2f230005b3950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b37ecbfc5dcafa0325439f72fdb32a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#aa1b37ecbfc5dcafa0325439f72fdb32a">getShape</a> () const override</td></tr>
<tr class="memdesc:aa1b37ecbfc5dcafa0325439f72fdb32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the shape of the tensor in the form of a std::vector of integers.  <a href="#aa1b37ecbfc5dcafa0325439f72fdb32a">More...</a><br /></td></tr>
<tr class="separator:aa1b37ecbfc5dcafa0325439f72fdb32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a215382d81df0b37903a55dd56d485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a41a215382d81df0b37903a55dd56d485">setArgument</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, int iArg=0) override</td></tr>
<tr class="memdesc:a41a215382d81df0b37903a55dd56d485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the argument at position <b>iArg</b> (default=0).  <a href="#a41a215382d81df0b37903a55dd56d485">More...</a><br /></td></tr>
<tr class="separator:a41a215382d81df0b37903a55dd56d485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55833e40303f215acf7641c47318bb92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a55833e40303f215acf7641c47318bb92">setArgument</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, const std::initializer_list&lt; int &gt; &amp;indices) override</td></tr>
<tr class="memdesc:a55833e40303f215acf7641c47318bb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions.  <a href="#a55833e40303f215acf7641c47318bb92">More...</a><br /></td></tr>
<tr class="separator:a55833e40303f215acf7641c47318bb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94121f60b12f43e773d162bc1a4f2989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a94121f60b12f43e773d162bc1a4f2989">setArgument</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, const std::vector&lt; int &gt; &amp;indices) override</td></tr>
<tr class="memdesc:a94121f60b12f43e773d162bc1a4f2989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions.  <a href="#a94121f60b12f43e773d162bc1a4f2989">More...</a><br /></td></tr>
<tr class="separator:a94121f60b12f43e773d162bc1a4f2989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91d8c931bcc6bd05116a7001df7c158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#aa91d8c931bcc6bd05116a7001df7c158">setVectorArgument</a> (const std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt; &amp;t_argument) override</td></tr>
<tr class="memdesc:aa91d8c931bcc6bd05116a7001df7c158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the entire std::vector of argument.  <a href="#aa91d8c931bcc6bd05116a7001df7c158">More...</a><br /></td></tr>
<tr class="separator:aa91d8c931bcc6bd05116a7001df7c158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41679a5ac7ec7a7b338d7a240fa9a0ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a41679a5ac7ec7a7b338d7a240fa9a0ec">matchShape</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, bool exact=false) const override</td></tr>
<tr class="memdesc:a41679a5ac7ec7a7b338d7a240fa9a0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case of a vectorial-type expression, this function checks if the shape of expr matches itself.  <a href="#a41679a5ac7ec7a7b338d7a240fa9a0ec">More...</a><br /></td></tr>
<tr class="separator:a41679a5ac7ec7a7b338d7a240fa9a0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dff10409a8d15f6be4054320ef7f2b6"><td class="memItemLeft" align="right" valign="top"><a id="a3dff10409a8d15f6be4054320ef7f2b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>exactMatchShape</b> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="separator:a3dff10409a8d15f6be4054320ef7f2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffa89e0d4c9e3a8bb3aa5959249ab55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#afffa89e0d4c9e3a8bb3aa5959249ab55">getSum</a> () const override</td></tr>
<tr class="memdesc:afffa89e0d4c9e3a8bb3aa5959249ab55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the sum of all elements in the <b>Vectorial</b> object.  <a href="#afffa89e0d4c9e3a8bb3aa5959249ab55">More...</a><br /></td></tr>
<tr class="separator:afffa89e0d4c9e3a8bb3aa5959249ab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace60e29a30276591e831a5b7c7660e5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#ace60e29a30276591e831a5b7c7660e5d">getProduct</a> () const override</td></tr>
<tr class="memdesc:ace60e29a30276591e831a5b7c7660e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the product of all elements in the <b>Vectorial</b> object.  <a href="#ace60e29a30276591e831a5b7c7660e5d">More...</a><br /></td></tr>
<tr class="separator:ace60e29a30276591e831a5b7c7660e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94e57a145012ad9e6d75e9b33501a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#af94e57a145012ad9e6d75e9b33501a98">getSubVectorial</a> (const std::vector&lt; int &gt; &amp;exceptions) const override</td></tr>
<tr class="memdesc:af94e57a145012ad9e6d75e9b33501a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element.  <a href="#af94e57a145012ad9e6d75e9b33501a98">More...</a><br /></td></tr>
<tr class="separator:af94e57a145012ad9e6d75e9b33501a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7a92b35a50908f79ded8dd5522150f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a8a7a92b35a50908f79ded8dd5522150f">getVectorialModulus</a> () const override</td></tr>
<tr class="memdesc:a8a7a92b35a50908f79ded8dd5522150f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Vectorial modulus of the <b>Vectorial</b> object, that is defined here as the squared root of the sum of element squared. Example: {A_{11}^2+A_{12}^2+}.  <a href="#a8a7a92b35a50908f79ded8dd5522150f">More...</a><br /></td></tr>
<tr class="separator:a8a7a92b35a50908f79ded8dd5522150f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c453ee7313a36cc1c2987833a38d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#aa8c453ee7313a36cc1c2987833a38d0e">dot</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const override</td></tr>
<tr class="memdesc:aa8c453ee7313a36cc1c2987833a38d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of two <b>Vectorial</b> expressions.  <a href="#aa8c453ee7313a36cc1c2987833a38d0e">More...</a><br /></td></tr>
<tr class="separator:aa8c453ee7313a36cc1c2987833a38d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e9b3d2f9ab4d020ca63082e78978b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a86e9b3d2f9ab4d020ca63082e78978b4">addition_own</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const override</td></tr>
<tr class="memdesc:a86e9b3d2f9ab4d020ca63082e78978b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special addition for Numerical- and Vectorial-types.  <a href="#a86e9b3d2f9ab4d020ca63082e78978b4">More...</a><br /></td></tr>
<tr class="separator:a86e9b3d2f9ab4d020ca63082e78978b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab648a7f5b3c4bea99303a80e1cb231"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a3ab648a7f5b3c4bea99303a80e1cb231">multiplication_own</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, bool side=1) const override</td></tr>
<tr class="memdesc:a3ab648a7f5b3c4bea99303a80e1cb231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special multiplication for Numerical- and Vectorial-types.  <a href="#a3ab648a7f5b3c4bea99303a80e1cb231">More...</a><br /></td></tr>
<tr class="separator:a3ab648a7f5b3c4bea99303a80e1cb231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adf32913aa9251d725b9e8acaf5d9ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a0adf32913aa9251d725b9e8acaf5d9ee">tensor_dot</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const override</td></tr>
<tr class="memdesc:a0adf32913aa9251d725b9e8acaf5d9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensor_dot of two <b>Vectorial</b> expressions.  <a href="#a0adf32913aa9251d725b9e8acaf5d9ee">More...</a><br /></td></tr>
<tr class="separator:a0adf32913aa9251d725b9e8acaf5d9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade105c7b96ac33d550011007c554b318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#ade105c7b96ac33d550011007c554b318">trace</a> (int axis1, int axis2) const override</td></tr>
<tr class="memdesc:ade105c7b96ac33d550011007c554b318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the trace over the axis <b>axis1</b> and <b>axis2</b> of a tensor. <b>axis1</b> and <b>axis2</b> can be the same, in which case the trace just corresponds to the sum over this particular axis.  <a href="#ade105c7b96ac33d550011007c554b318">More...</a><br /></td></tr>
<tr class="separator:ade105c7b96ac33d550011007c554b318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1ccb84aa901bcbba4394444d18c633"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#acf1ccb84aa901bcbba4394444d18c633">develop</a> (bool full=false) override</td></tr>
<tr class="memdesc:acf1ccb84aa901bcbba4394444d18c633"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Develops</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#acf1ccb84aa901bcbba4394444d18c633">More...</a><br /></td></tr>
<tr class="separator:acf1ccb84aa901bcbba4394444d18c633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d353d7c78473d62f37948937b41296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#ad9d353d7c78473d62f37948937b41296">factor</a> (bool full=false) override</td></tr>
<tr class="memdesc:ad9d353d7c78473d62f37948937b41296"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Factors</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#ad9d353d7c78473d62f37948937b41296">More...</a><br /></td></tr>
<tr class="separator:ad9d353d7c78473d62f37948937b41296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5c1e823756b633e949f2fc6072e6fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#afc5c1e823756b633e949f2fc6072e6fe">factor</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, bool full=false) override</td></tr>
<tr class="memdesc:afc5c1e823756b633e949f2fc6072e6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Factors</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt a <b>particular</b> <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#afc5c1e823756b633e949f2fc6072e6fe">More...</a><br /></td></tr>
<tr class="separator:afc5c1e823756b633e949f2fc6072e6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b2bc11074fbdb41c70125a5d9bf1ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#ac6b2bc11074fbdb41c70125a5d9bf1ab">operator==</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const override</td></tr>
<tr class="memdesc:ac6b2bc11074fbdb41c70125a5d9bf1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Compares</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another.  <a href="#ac6b2bc11074fbdb41c70125a5d9bf1ab">More...</a><br /></td></tr>
<tr class="separator:ac6b2bc11074fbdb41c70125a5d9bf1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b1c4cd3597712bc6250fc1b08d6d00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#a72b1c4cd3597712bc6250fc1b08d6d00">operator[]</a> (int iArg) override</td></tr>
<tr class="memdesc:a72b1c4cd3597712bc6250fc1b08d6d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator for multi-argument expressions, returns a reference so this function is not const.  <a href="#a72b1c4cd3597712bc6250fc1b08d6d00">More...</a><br /></td></tr>
<tr class="separator:a72b1c4cd3597712bc6250fc1b08d6d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3940fec5665747f69e980bb670a338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractVectorial.html#afa3940fec5665747f69e980bb670a338">operator[]</a> (int iArg) const override</td></tr>
<tr class="memdesc:afa3940fec5665747f69e980bb670a338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator for multi-argument expressions, equivalent to the function <a class="el" href="classAbstractVectorial.html#ae61b5bdbc1b2651da335257b057e7491">getArgument()</a>.  <a href="#afa3940fec5665747f69e980bb670a338">More...</a><br /></td></tr>
<tr class="separator:afa3940fec5665747f69e980bb670a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classAbstract"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classAbstract')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classAbstract.html">Abstract</a></td></tr>
<tr class="memitem:acc6e3314f7cec8a356e1ee6a9dde1d18 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#acc6e3314f7cec8a356e1ee6a9dde1d18">Abstract</a> ()</td></tr>
<tr class="memdesc:acc6e3314f7cec8a356e1ee6a9dde1d18 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="classAbstract.html#acc6e3314f7cec8a356e1ee6a9dde1d18">More...</a><br /></td></tr>
<tr class="separator:acc6e3314f7cec8a356e1ee6a9dde1d18 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738cc29f2abe8567c3f132198014e753 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top"><a id="a738cc29f2abe8567c3f132198014e753"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a738cc29f2abe8567c3f132198014e753">Abstract</a> (const std::string &amp;t_name)</td></tr>
<tr class="memdesc:a738cc29f2abe8567c3f132198014e753 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name to t_name and commutable to <b>True</b>. <br /></td></tr>
<tr class="separator:a738cc29f2abe8567c3f132198014e753 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ef9b71019b8c2c3b9133497349262e inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top"><a id="a67ef9b71019b8c2c3b9133497349262e"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a67ef9b71019b8c2c3b9133497349262e">~Abstract</a> ()</td></tr>
<tr class="memdesc:a67ef9b71019b8c2c3b9133497349262e inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a67ef9b71019b8c2c3b9133497349262e inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f86250bd135d34203d40020a6c9b56f inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8f86250bd135d34203d40020a6c9b56f">printExplicit</a> (int mode=0) const</td></tr>
<tr class="memdesc:a8f86250bd135d34203d40020a6c9b56f inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays explicitely the expression, with types of each component. This function is only used for debug.  <a href="classAbstract.html#a8f86250bd135d34203d40020a6c9b56f">More...</a><br /></td></tr>
<tr class="separator:a8f86250bd135d34203d40020a6c9b56f inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a60438a5b55d0b2ceb35c8674b9d8c5 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8a60438a5b55d0b2ceb35c8674b9d8c5">getName</a> () const</td></tr>
<tr class="memdesc:a8a60438a5b55d0b2ceb35c8674b9d8c5 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>'s name.  <a href="classAbstract.html#a8a60438a5b55d0b2ceb35c8674b9d8c5">More...</a><br /></td></tr>
<tr class="separator:a8a60438a5b55d0b2ceb35c8674b9d8c5 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008f58643c15d4f624e6aee7a98e699c inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a008f58643c15d4f624e6aee7a98e699c">getCommutable</a> () const</td></tr>
<tr class="memdesc:a008f58643c15d4f624e6aee7a98e699c inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to know if the object commutes with all the others.  <a href="classAbstract.html#a008f58643c15d4f624e6aee7a98e699c">More...</a><br /></td></tr>
<tr class="separator:a008f58643c15d4f624e6aee7a98e699c inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac545afdeb8b1724b1e8aff98b059b52c inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a1d1cfd8ffb84e947f82999c682b666a7">smType::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ac545afdeb8b1724b1e8aff98b059b52c">getType</a> () const =0</td></tr>
<tr class="memdesc:ac545afdeb8b1724b1e8aff98b059b52c inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>type</b> of <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="classAbstract.html#ac545afdeb8b1724b1e8aff98b059b52c">More...</a><br /></td></tr>
<tr class="separator:ac545afdeb8b1724b1e8aff98b059b52c inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134526a9e561b38741398c32f76c91b8 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a134526a9e561b38741398c32f76c91b8">isBuildingBlock</a> () const</td></tr>
<tr class="memdesc:a134526a9e561b38741398c32f76c91b8 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is a Building Block or not.  <a href="classAbstract.html#a134526a9e561b38741398c32f76c91b8">More...</a><br /></td></tr>
<tr class="separator:a134526a9e561b38741398c32f76c91b8 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3672834c6627f73acc4219096301ada inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#aa3672834c6627f73acc4219096301ada">isIndexed</a> () const</td></tr>
<tr class="separator:aa3672834c6627f73acc4219096301ada inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b814b0ea2da2ab605b5073c6ff20e6 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classEquation.html">Equation</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a19b814b0ea2da2ab605b5073c6ff20e6">getProperties</a> () const</td></tr>
<tr class="separator:a19b814b0ea2da2ab605b5073c6ff20e6 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f96f613f3813778606654fc57b9256b inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8f96f613f3813778606654fc57b9256b">isInteger</a> () const</td></tr>
<tr class="memdesc:a8f96f613f3813778606654fc57b9256b inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is an integer. Either an <a class="el" href="classInteger.html" title="Handle numbers in expr. ">Integer</a> object directly, or a <a class="el" href="classDouble.html" title="Handle numbers in expr. ">Double</a> that has an integer value.  <a href="classAbstract.html#a8f96f613f3813778606654fc57b9256b">More...</a><br /></td></tr>
<tr class="separator:a8f96f613f3813778606654fc57b9256b inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57c83bb6e902a6a15a361e3b23fc5df inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ac57c83bb6e902a6a15a361e3b23fc5df">getValued</a> () const</td></tr>
<tr class="memdesc:ac57c83bb6e902a6a15a361e3b23fc5df inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is valued, i.e. is a function of numbers and valued literals (a <a class="el" href="classVariable.html" title="Handle an object with a name and a value. ">Variable</a> or <a class="el" href="classConstant.html" title="Handle an object with a name and a value. ">Constant</a> is not valued by default).  <a href="classAbstract.html#ac57c83bb6e902a6a15a361e3b23fc5df">More...</a><br /></td></tr>
<tr class="separator:ac57c83bb6e902a6a15a361e3b23fc5df inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba57b14ff887eea4ef9e031d69374cb inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#acba57b14ff887eea4ef9e031d69374cb">getValue</a> () const</td></tr>
<tr class="memdesc:acba57b14ff887eea4ef9e031d69374cb inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the expression, if it has one <b>explicitely</b>. In particular, it will work only on Numbers and valued Literals, not on functions.  <a href="classAbstract.html#acba57b14ff887eea4ef9e031d69374cb">More...</a><br /></td></tr>
<tr class="separator:acba57b14ff887eea4ef9e031d69374cb inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa98d0f2d18bf275f6654a7fadd538e4 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#afa98d0f2d18bf275f6654a7fadd538e4">getNum</a> () const</td></tr>
<tr class="separator:afa98d0f2d18bf275f6654a7fadd538e4 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a452f6609a695e82dbec0924fe6ad53 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a2a452f6609a695e82dbec0924fe6ad53">getDenom</a> () const</td></tr>
<tr class="separator:a2a452f6609a695e82dbec0924fe6ad53 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d5fffe1213a826543171b4330af099 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#af2d5fffe1213a826543171b4330af099">getVariable</a> () const</td></tr>
<tr class="memdesc:af2d5fffe1213a826543171b4330af099 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the variable that defines certain types of expressions.  <a href="classAbstract.html#af2d5fffe1213a826543171b4330af099">More...</a><br /></td></tr>
<tr class="separator:af2d5fffe1213a826543171b4330af099 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7f724371bd2b5c61d3615faef63beb inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6d7f724371bd2b5c61d3615faef63beb">getOrder</a> () const</td></tr>
<tr class="memdesc:a6d7f724371bd2b5c61d3615faef63beb inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the order (integer) that defines certain types of expressions.  <a href="classAbstract.html#a6d7f724371bd2b5c61d3615faef63beb">More...</a><br /></td></tr>
<tr class="separator:a6d7f724371bd2b5c61d3615faef63beb inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#acf82f9b2937375c7b1cf3dccb3df3312">isEmpty</a> () const</td></tr>
<tr class="memdesc:acf82f9b2937375c7b1cf3dccb3df3312 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells for a <a class="el" href="classDerivative.html" title="Handles the exponentiation of one Abstract wrt another. ">Derivative</a> or an Integral if the argument is empty i.e. if the object must apply on the next argument encountered on the right.  <a href="classAbstract.html#acf82f9b2937375c7b1cf3dccb3df3312">More...</a><br /></td></tr>
<tr class="separator:acf82f9b2937375c7b1cf3dccb3df3312 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac702310492abaed2dfef1ee4d988d7c2 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ac702310492abaed2dfef1ee4d988d7c2">getNIndices</a> () const</td></tr>
<tr class="separator:ac702310492abaed2dfef1ee4d988d7c2 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3168305d646a6d19ec0f03186113145f inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual Idx&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a3168305d646a6d19ec0f03186113145f">getIndex</a> (int i=0) const</td></tr>
<tr class="separator:a3168305d646a6d19ec0f03186113145f inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd19eb640458e6e70ddaf35115aa2d2 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classIndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6bd19eb640458e6e70ddaf35115aa2d2">getIndexStructure</a> () const</td></tr>
<tr class="separator:a6bd19eb640458e6e70ddaf35115aa2d2 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0155b96e56789963f35a026de1da02 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classIndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a3d0155b96e56789963f35a026de1da02">getFreeIndexStructure</a> () const</td></tr>
<tr class="separator:a3d0155b96e56789963f35a026de1da02 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97560d38a511d2abe349521bb71b57ff inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classIndicialParent.html">IndicialParent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a97560d38a511d2abe349521bb71b57ff">getParent</a> () const</td></tr>
<tr class="memdesc:a97560d38a511d2abe349521bb71b57ff inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">For indicial expressions this function returns a pointer to the parent object of type <a class="el" href="classIndicialParent.html">IndicialParent</a> (not an expression).  <a href="classAbstract.html#a97560d38a511d2abe349521bb71b57ff">More...</a><br /></td></tr>
<tr class="separator:a97560d38a511d2abe349521bb71b57ff inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39a18f5d58508346e4c19d3c26a80d4 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ae39a18f5d58508346e4c19d3c26a80d4">getNContractedPairs</a> () const</td></tr>
<tr class="memdesc:ae39a18f5d58508346e4c19d3c26a80d4 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of contracted pairs of indices <b>in an Indicial expression</b>.  <a href="classAbstract.html#ae39a18f5d58508346e4c19d3c26a80d4">More...</a><br /></td></tr>
<tr class="separator:ae39a18f5d58508346e4c19d3c26a80d4 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bc1c2804eeb41a6ce2eaca0d741cf8 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a13bc1c2804eeb41a6ce2eaca0d741cf8">getPermutations</a> () const</td></tr>
<tr class="memdesc:a13bc1c2804eeb41a6ce2eaca0d741cf8 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::vector of all possible permutations of an <b>Indicial</b> expression. The possible permutations are determined from the posible symmetries and anti-symmetries of the object.  <a href="classAbstract.html#a13bc1c2804eeb41a6ce2eaca0d741cf8">More...</a><br /></td></tr>
<tr class="separator:a13bc1c2804eeb41a6ce2eaca0d741cf8 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fa50ffd1b16b2ff0ad421a3a0760c1 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual std::set&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a55fa50ffd1b16b2ff0ad421a3a0760c1">getContractedPair</a> () const</td></tr>
<tr class="separator:a55fa50ffd1b16b2ff0ad421a3a0760c1 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad305ee5e54d468c64c6b46658aa210e0 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ad305ee5e54d468c64c6b46658aa210e0">setName</a> (const std::string &amp;t_name)</td></tr>
<tr class="memdesc:ad305ee5e54d468c64c6b46658aa210e0 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the name of the abstract.  <a href="classAbstract.html#ad305ee5e54d468c64c6b46658aa210e0">More...</a><br /></td></tr>
<tr class="separator:ad305ee5e54d468c64c6b46658aa210e0 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128daf984905d30e5c966492001c23b4 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a128daf984905d30e5c966492001c23b4">setCommutable</a> (bool t_commutable)</td></tr>
<tr class="memdesc:a128daf984905d30e5c966492001c23b4 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the abstract to commute or not.  <a href="classAbstract.html#a128daf984905d30e5c966492001c23b4">More...</a><br /></td></tr>
<tr class="separator:a128daf984905d30e5c966492001c23b4 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0978d1c8d671975134de12d7f71d31f inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ac0978d1c8d671975134de12d7f71d31f">addProperty</a> (<a class="el" href="classEquation.html">Equation</a> *property)</td></tr>
<tr class="memdesc:ac0978d1c8d671975134de12d7f71d31f inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a property to the object.  <a href="classAbstract.html#ac0978d1c8d671975134de12d7f71d31f">More...</a><br /></td></tr>
<tr class="separator:ac0978d1c8d671975134de12d7f71d31f inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154f804eaf05e8fe148a4008bd60a746 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a154f804eaf05e8fe148a4008bd60a746">removeProperty</a> (<a class="el" href="classEquation.html">Equation</a> *property)</td></tr>
<tr class="memdesc:a154f804eaf05e8fe148a4008bd60a746 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a property to the object.  <a href="classAbstract.html#a154f804eaf05e8fe148a4008bd60a746">More...</a><br /></td></tr>
<tr class="separator:a154f804eaf05e8fe148a4008bd60a746 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf2751548904140aa7aa4a1e8e59346 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top"><a id="afbf2751548904140aa7aa4a1e8e59346"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#afbf2751548904140aa7aa4a1e8e59346">setValue</a> (double t_value)</td></tr>
<tr class="memdesc:afbf2751548904140aa7aa4a1e8e59346 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value if there is one (for Numerical and Literal valued). <br /></td></tr>
<tr class="separator:afbf2751548904140aa7aa4a1e8e59346 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0237c2d597fd1628b888f55c67b03578 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top"><a id="a0237c2d597fd1628b888f55c67b03578"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setElementary</b> (bool t_elementary)</td></tr>
<tr class="separator:a0237c2d597fd1628b888f55c67b03578 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959865229b8270687bbe0c749ac2e9b1 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top"><a id="a959865229b8270687bbe0c749ac2e9b1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setAllDependencies</b> (bool t_allDependencies)</td></tr>
<tr class="separator:a959865229b8270687bbe0c749ac2e9b1 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a3a1c805e2d2400e33fda95c0083ca inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top"><a id="a17a3a1c805e2d2400e33fda95c0083ca"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addDependency</b> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a17a3a1c805e2d2400e33fda95c0083ca inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c3bee67324dbaa499011a6e7c6e66a inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top"><a id="a44c3bee67324dbaa499011a6e7c6e66a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeDependency</b> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a44c3bee67324dbaa499011a6e7c6e66a inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3137c0d5e3ebd67e695ce21732dc26ef inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a3137c0d5e3ebd67e695ce21732dc26ef">insert</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, bool side=1)</td></tr>
<tr class="memdesc:a3137c0d5e3ebd67e695ce21732dc26ef inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an expression in a sum or a product.  <a href="classAbstract.html#a3137c0d5e3ebd67e695ce21732dc26ef">More...</a><br /></td></tr>
<tr class="separator:a3137c0d5e3ebd67e695ce21732dc26ef inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e74b931921f8f8d95d8d46a27eb972f inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a3e74b931921f8f8d95d8d46a27eb972f">replaceIndex</a> (const Idx &amp;indexToReplace, const Idx &amp;newIndex)</td></tr>
<tr class="memdesc:a3e74b931921f8f8d95d8d46a27eb972f inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">For indicial expressions, this function searches <b>indexToContract</b> and replaces it with newIndex.  <a href="classAbstract.html#a3e74b931921f8f8d95d8d46a27eb972f">More...</a><br /></td></tr>
<tr class="separator:a3e74b931921f8f8d95d8d46a27eb972f inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852436229babbdf96dd5aafb15660cd6 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a852436229babbdf96dd5aafb15660cd6">setIndexStructure</a> (const <a class="el" href="classIndexStructure.html">IndexStructure</a> &amp;t_index)</td></tr>
<tr class="memdesc:a852436229babbdf96dd5aafb15660cd6 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the index structure of the object, that must be an <b>Indicial</b> expression.  <a href="classAbstract.html#a852436229babbdf96dd5aafb15660cd6">More...</a><br /></td></tr>
<tr class="separator:a852436229babbdf96dd5aafb15660cd6 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac102096971b80a7510a4cb9da4ab6b03 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top"><a id="ac102096971b80a7510a4cb9da4ab6b03"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ac102096971b80a7510a4cb9da4ab6b03">setFullySymmetric</a> ()</td></tr>
<tr class="memdesc:ac102096971b80a7510a4cb9da4ab6b03 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an <b>Indicial</b> object fully symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties of symmetry / antisymmetry and sets <b>fullySymmetric</b> to <b>True</b>. <br /></td></tr>
<tr class="separator:ac102096971b80a7510a4cb9da4ab6b03 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfef4ff87acec837e64ff73ccffdf369 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top"><a id="acfef4ff87acec837e64ff73ccffdf369"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#acfef4ff87acec837e64ff73ccffdf369">setFullyAntiSymmetric</a> ()</td></tr>
<tr class="memdesc:acfef4ff87acec837e64ff73ccffdf369 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an <b>Indicial</b> object fully anti-symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties * of symmetry / antisymmetry and sets <b>fullyAntiSymmetric</b> to <b>True</b>. <br /></td></tr>
<tr class="separator:acfef4ff87acec837e64ff73ccffdf369 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7ae515cba43be48adbca7f6a8b6106 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a0e7ae515cba43be48adbca7f6a8b6106">addSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:a0e7ae515cba43be48adbca7f6a8b6106 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a symmetry between the i1^{th} and the i2^{th} indices. If those indices are anti-symmetric, an error is thrown.  <a href="classAbstract.html#a0e7ae515cba43be48adbca7f6a8b6106">More...</a><br /></td></tr>
<tr class="separator:a0e7ae515cba43be48adbca7f6a8b6106 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fccaaa8870d764767ea291b351dc694 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a1fccaaa8870d764767ea291b351dc694">addAntiSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:a1fccaaa8870d764767ea291b351dc694 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an anti-symmetry between the i1^{th} and the i2^{th} indices. If those indices are symmetric, an error is thrown.  <a href="classAbstract.html#a1fccaaa8870d764767ea291b351dc694">More...</a><br /></td></tr>
<tr class="separator:a1fccaaa8870d764767ea291b351dc694 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f5a37ad523ec663a61d07def420820 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ae9f5a37ad523ec663a61d07def420820">permut</a> (int i1, int i2)</td></tr>
<tr class="memdesc:ae9f5a37ad523ec663a61d07def420820 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to permut indices at place <b>i1</b> and <b>i2</b>. If those two indices have a symmetry property, indices are swaped and the symmetry is returned. Else the fnuction does nothing and returns 0.  <a href="classAbstract.html#ae9f5a37ad523ec663a61d07def420820">More...</a><br /></td></tr>
<tr class="separator:ae9f5a37ad523ec663a61d07def420820 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839372b7667ea0a28a9e3b72112366ff inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a839372b7667ea0a28a9e3b72112366ff">getNumericalFactor</a> () const</td></tr>
<tr class="memdesc:a839372b7667ea0a28a9e3b72112366ff inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the numerical factor of the expression, i.e. returns <b>C</b> if the expression if of the form <b>C*x</b> (<b>x</b> having a numerical factor equal to 1), and return 1 else.  <a href="classAbstract.html#a839372b7667ea0a28a9e3b72112366ff">More...</a><br /></td></tr>
<tr class="separator:a839372b7667ea0a28a9e3b72112366ff inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594a570f0139f92f284f31e91c0c6dd8 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a594a570f0139f92f284f31e91c0c6dd8">getNFactor</a> () const</td></tr>
<tr class="separator:a594a570f0139f92f284f31e91c0c6dd8 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdf2d5371e8c8ead87ef2b5d6fe43c0 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a5fdf2d5371e8c8ead87ef2b5d6fe43c0">getFactors</a> () const</td></tr>
<tr class="memdesc:a5fdf2d5371e8c8ead87ef2b5d6fe43c0 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get a std::vector of all terms than could factor the expression.  <a href="classAbstract.html#a5fdf2d5371e8c8ead87ef2b5d6fe43c0">More...</a><br /></td></tr>
<tr class="separator:a5fdf2d5371e8c8ead87ef2b5d6fe43c0 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eab0d3915f47bc492ecaaf508afca4 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ad4eab0d3915f47bc492ecaaf508afca4">getTerm</a> ()</td></tr>
<tr class="memdesc:ad4eab0d3915f47bc492ecaaf508afca4 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the same expression as *this but amputated of its numerical factor. Example: (4*cos(x) -&gt; cos(x)).  <a href="classAbstract.html#ad4eab0d3915f47bc492ecaaf508afca4">More...</a><br /></td></tr>
<tr class="separator:ad4eab0d3915f47bc492ecaaf508afca4 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea7157d55f9cb98ad24c25e7fcf1142 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a2ea7157d55f9cb98ad24c25e7fcf1142">checkIndexStructure</a> (const std::vector&lt; Idx &gt; &amp;t_index) const</td></tr>
<tr class="memdesc:a2ea7157d55f9cb98ad24c25e7fcf1142 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure.  <a href="classAbstract.html#a2ea7157d55f9cb98ad24c25e7fcf1142">More...</a><br /></td></tr>
<tr class="separator:a2ea7157d55f9cb98ad24c25e7fcf1142 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0aa373699933305cfb8ff9ba5da752b inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ab0aa373699933305cfb8ff9ba5da752b">checkIndexStructure</a> (const std::initializer_list&lt; Idx &gt; &amp;index) const</td></tr>
<tr class="memdesc:ab0aa373699933305cfb8ff9ba5da752b inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure.  <a href="classAbstract.html#ab0aa373699933305cfb8ff9ba5da752b">More...</a><br /></td></tr>
<tr class="separator:ab0aa373699933305cfb8ff9ba5da752b inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f280a5666c623e19ee5096bf5c60ac1 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top"><a id="a6f280a5666c623e19ee5096bf5c60ac1"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>compareWithDummy</b> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, std::map&lt; <a class="el" href="classIndex.html">Index</a>, <a class="el" href="classIndex.html">Index</a> &gt; &amp;constraints) const</td></tr>
<tr class="separator:a6f280a5666c623e19ee5096bf5c60ac1 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950163457cbd6cef954422a1821eda7a inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a950163457cbd6cef954422a1821eda7a">getParity</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;t_variable) const</td></tr>
<tr class="memdesc:a950163457cbd6cef954422a1821eda7a inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parity property of the expression with respect to <b>t_variable</b>.  <a href="classAbstract.html#a950163457cbd6cef954422a1821eda7a">More...</a><br /></td></tr>
<tr class="separator:a950163457cbd6cef954422a1821eda7a inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c858cbdb891b94ed1d2166f3b8392d inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a50c858cbdb891b94ed1d2166f3b8392d">askTerm</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr, bool exact=false) const</td></tr>
<tr class="memdesc:a50c858cbdb891b94ed1d2166f3b8392d inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <b>expr</b> can factor <b>*this</b>.  <a href="classAbstract.html#a50c858cbdb891b94ed1d2166f3b8392d">More...</a><br /></td></tr>
<tr class="separator:a50c858cbdb891b94ed1d2166f3b8392d inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6750df27f71d1c2e35d7a7f75c16d5 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6e6750df27f71d1c2e35d7a7f75c16d5">dependsOn</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a6e6750df27f71d1c2e35d7a7f75c16d5 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check recursively if the expression depends on <b>expr</b>.  <a href="classAbstract.html#a6e6750df27f71d1c2e35d7a7f75c16d5">More...</a><br /></td></tr>
<tr class="separator:a6e6750df27f71d1c2e35d7a7f75c16d5 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6c14ad785fb921be36997bfa749e59 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a7e6c14ad785fb921be36997bfa749e59">dependsExplicitelyOn</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a7e6c14ad785fb921be36997bfa749e59 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check recursively if <b>expr</b> is present in the expression.  <a href="classAbstract.html#a7e6c14ad785fb921be36997bfa749e59">More...</a><br /></td></tr>
<tr class="separator:a7e6c14ad785fb921be36997bfa749e59 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2e0d6e4b236fe9162e952407dc0615 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#adf2e0d6e4b236fe9162e952407dc0615">findSubExpression</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;subExpression, const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;newExpression)</td></tr>
<tr class="memdesc:adf2e0d6e4b236fe9162e952407dc0615 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a sub-expression and replaces it.  <a href="classAbstract.html#adf2e0d6e4b236fe9162e952407dc0615">More...</a><br /></td></tr>
<tr class="separator:adf2e0d6e4b236fe9162e952407dc0615 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fb27a847c4aceb353cce8183df51be inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#af5fb27a847c4aceb353cce8183df51be">isPolynomial</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:af5fb27a847c4aceb353cce8183df51be inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the expression is a mononomial term in <b>expr</b>, i.e. a term of the form C*expr^n with C independent of expr, n integer.  <a href="classAbstract.html#af5fb27a847c4aceb353cce8183df51be">More...</a><br /></td></tr>
<tr class="separator:af5fb27a847c4aceb353cce8183df51be inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd473f3a4f62f338f5b0ee3b10453f39 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#abd473f3a4f62f338f5b0ee3b10453f39">evaluateScalar</a> () const</td></tr>
<tr class="memdesc:abd473f3a4f62f338f5b0ee3b10453f39 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the value of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="classAbstract.html#abd473f3a4f62f338f5b0ee3b10453f39">More...</a><br /></td></tr>
<tr class="separator:abd473f3a4f62f338f5b0ee3b10453f39 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0051bf527eff054316fb14511d10e155 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a0051bf527eff054316fb14511d10e155">derive</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a0051bf527eff054316fb14511d10e155 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivative of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt another.  <a href="classAbstract.html#a0051bf527eff054316fb14511d10e155">More...</a><br /></td></tr>
<tr class="separator:a0051bf527eff054316fb14511d10e155 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ac62534de5f3fd86899a9c2edb8f43 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a50ac62534de5f3fd86899a9c2edb8f43">suppressTerm</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a50ac62534de5f3fd86899a9c2edb8f43 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a factor from an expr, that must have been determined before.  <a href="classAbstract.html#a50ac62534de5f3fd86899a9c2edb8f43">More...</a><br /></td></tr>
<tr class="separator:a50ac62534de5f3fd86899a9c2edb8f43 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3cdd2b7bf7c6a6df773b68c9af5153 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#afc3cdd2b7bf7c6a6df773b68c9af5153">getRealPart</a> ()</td></tr>
<tr class="memdesc:afc3cdd2b7bf7c6a6df773b68c9af5153 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>real part</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classAbstract.html#afc3cdd2b7bf7c6a6df773b68c9af5153">More...</a><br /></td></tr>
<tr class="separator:afc3cdd2b7bf7c6a6df773b68c9af5153 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc37867d634b3538379f6256d6c7e29 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6fc37867d634b3538379f6256d6c7e29">getImaginaryPart</a> () const</td></tr>
<tr class="memdesc:a6fc37867d634b3538379f6256d6c7e29 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>imaginary part</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classAbstract.html#a6fc37867d634b3538379f6256d6c7e29">More...</a><br /></td></tr>
<tr class="separator:a6fc37867d634b3538379f6256d6c7e29 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff23826dac23c21b39a9d4ef59d50c76 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#aff23826dac23c21b39a9d4ef59d50c76">getComplexModulus</a> ()</td></tr>
<tr class="memdesc:aff23826dac23c21b39a9d4ef59d50c76 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>modulus in the complex plane</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classAbstract.html#aff23826dac23c21b39a9d4ef59d50c76">More...</a><br /></td></tr>
<tr class="separator:aff23826dac23c21b39a9d4ef59d50c76 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a594594ebcc69a4945ab6890e203deb inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a0a594594ebcc69a4945ab6890e203deb">getComplexArgument</a> ()</td></tr>
<tr class="memdesc:a0a594594ebcc69a4945ab6890e203deb inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>argument in the complex plane</b> of the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classAbstract.html#a0a594594ebcc69a4945ab6890e203deb">More...</a><br /></td></tr>
<tr class="separator:a0a594594ebcc69a4945ab6890e203deb inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3317c522a29f999c5631d7e3b6431372 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a3317c522a29f999c5631d7e3b6431372">getComplexConjugate</a> ()</td></tr>
<tr class="memdesc:a3317c522a29f999c5631d7e3b6431372 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the complex conjugate of the expression.  <a href="classAbstract.html#a3317c522a29f999c5631d7e3b6431372">More...</a><br /></td></tr>
<tr class="separator:a3317c522a29f999c5631d7e3b6431372 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fa7ef6049a03bb02382ee6f6cde2f9 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a69fa7ef6049a03bb02382ee6f6cde2f9">getPolynomialTerm</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;t_variable, int order)</td></tr>
<tr class="memdesc:a69fa7ef6049a03bb02382ee6f6cde2f9 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the polynomial term corresponding to <b>*this</b> with the variable <b>t_variable</b> at order <b>order</b>. In particular, this function assumes that the checks have already been made with the function <a class="el" href="classAbstract.html#af5fb27a847c4aceb353cce8183df51be" title="Determines if the expression is a mononomial term in expr, i.e. a term of the form C*expr^n with C in...">isPolynomial()</a>.  <a href="classAbstract.html#a69fa7ef6049a03bb02382ee6f6cde2f9">More...</a><br /></td></tr>
<tr class="separator:a69fa7ef6049a03bb02382ee6f6cde2f9 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6979d84d75c4d4057d961ad84043dbd9 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a6979d84d75c4d4057d961ad84043dbd9">getAlternateForms</a> () const</td></tr>
<tr class="memdesc:a6979d84d75c4d4057d961ad84043dbd9 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns all possible alternate forms of the expression in terms of simplifications. For example 1-sin^2(x) is one of the alternate forms of cos^2(x).  <a href="classAbstract.html#a6979d84d75c4d4057d961ad84043dbd9">More...</a><br /></td></tr>
<tr class="separator:a6979d84d75c4d4057d961ad84043dbd9 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab218b3bc5d3930191ded81b2d689ab2d inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ab218b3bc5d3930191ded81b2d689ab2d">division_own</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:ab218b3bc5d3930191ded81b2d689ab2d inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special division for Numerical- and Polynomial-types. For polynomial, the euclidean division of two polynomials is implemented.  <a href="classAbstract.html#ab218b3bc5d3930191ded81b2d689ab2d">More...</a><br /></td></tr>
<tr class="separator:ab218b3bc5d3930191ded81b2d689ab2d inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc999066a217b4fd767dadb5114d3698 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#abc999066a217b4fd767dadb5114d3698">exponentiation_own</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:abc999066a217b4fd767dadb5114d3698 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special exponentiation for Numerical- and Vectorial-types.  <a href="classAbstract.html#abc999066a217b4fd767dadb5114d3698">More...</a><br /></td></tr>
<tr class="separator:abc999066a217b4fd767dadb5114d3698 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e5fc56dcab6f16259d0e6925aa51c0 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ab5e5fc56dcab6f16259d0e6925aa51c0">getRegularExpression</a> () const</td></tr>
<tr class="memdesc:ab5e5fc56dcab6f16259d0e6925aa51c0 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a regular expression from the polynomial, that is a sum where the different powers of the variable appear explicitely.  <a href="classAbstract.html#ab5e5fc56dcab6f16259d0e6925aa51c0">More...</a><br /></td></tr>
<tr class="separator:ab5e5fc56dcab6f16259d0e6925aa51c0 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57bb5ebdd5cd06237267a4c26b61590 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ab57bb5ebdd5cd06237267a4c26b61590">getSubVectorial</a> (int iExcept) const</td></tr>
<tr class="memdesc:ab57bb5ebdd5cd06237267a4c26b61590 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element.  <a href="classAbstract.html#ab57bb5ebdd5cd06237267a4c26b61590">More...</a><br /></td></tr>
<tr class="separator:ab57bb5ebdd5cd06237267a4c26b61590 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409da64180d33314dc802014dc6d963f inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a409da64180d33314dc802014dc6d963f">getSubVectorial</a> (int iExcept, int jExcept) const</td></tr>
<tr class="memdesc:a409da64180d33314dc802014dc6d963f inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the [iExcept^{th},jExcept^{th}] element (useful for matrices).  <a href="classAbstract.html#a409da64180d33314dc802014dc6d963f">More...</a><br /></td></tr>
<tr class="separator:a409da64180d33314dc802014dc6d963f inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aebaa743c24d2faf6b9f2576c21a1df inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a9aebaa743c24d2faf6b9f2576c21a1df">determinant</a> () const</td></tr>
<tr class="memdesc:a9aebaa743c24d2faf6b9f2576c21a1df inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the object if it corresponds to a square matrix (or a scalar), 0 else.  <a href="classAbstract.html#a9aebaa743c24d2faf6b9f2576c21a1df">More...</a><br /></td></tr>
<tr class="separator:a9aebaa743c24d2faf6b9f2576c21a1df inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ebeb9355bb8491aeb909094ef1a946 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a31ebeb9355bb8491aeb909094ef1a946">trace</a> () const</td></tr>
<tr class="separator:a31ebeb9355bb8491aeb909094ef1a946 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c28051b0366bafc6dcb0704d765fe9 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a23c28051b0366bafc6dcb0704d765fe9">transpose</a> () const</td></tr>
<tr class="memdesc:a23c28051b0366bafc6dcb0704d765fe9 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the transpose of a 2D matrix.  <a href="classAbstract.html#a23c28051b0366bafc6dcb0704d765fe9">More...</a><br /></td></tr>
<tr class="separator:a23c28051b0366bafc6dcb0704d765fe9 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8269986297fc4b551de89d6d3900ca36 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8269986297fc4b551de89d6d3900ca36">symmetrise</a> () const</td></tr>
<tr class="memdesc:a8269986297fc4b551de89d6d3900ca36 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the symmetrization of a 2D matrix.  <a href="classAbstract.html#a8269986297fc4b551de89d6d3900ca36">More...</a><br /></td></tr>
<tr class="separator:a8269986297fc4b551de89d6d3900ca36 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457f5c71cab762a8a8565479a732d7bd inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a457f5c71cab762a8a8565479a732d7bd">antisymmetrise</a> () const</td></tr>
<tr class="memdesc:a457f5c71cab762a8a8565479a732d7bd inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the anti-symmetrization of a 2D matrix.  <a href="classAbstract.html#a457f5c71cab762a8a8565479a732d7bd">More...</a><br /></td></tr>
<tr class="separator:a457f5c71cab762a8a8565479a732d7bd inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bec3a80614b4fa4352577eb0528b79 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#aa7bec3a80614b4fa4352577eb0528b79">inverseMatrix</a> () const</td></tr>
<tr class="memdesc:aa7bec3a80614b4fa4352577eb0528b79 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the inverse of a 2D square matrix. The applied method is: A^{-1} = 1/det(A)*Com(A)^T.  <a href="classAbstract.html#aa7bec3a80614b4fa4352577eb0528b79">More...</a><br /></td></tr>
<tr class="separator:aa7bec3a80614b4fa4352577eb0528b79 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e27d5fe7cf8a4db9e837a024b8e73e inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a45e27d5fe7cf8a4db9e837a024b8e73e">operator=</a> (double t_value)</td></tr>
<tr class="memdesc:a45e27d5fe7cf8a4db9e837a024b8e73e inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the <a class="el" href="classAbstract.html#afbf2751548904140aa7aa4a1e8e59346" title="Sets the value if there is one (for Numerical and Literal valued). ">setValue()</a> function.  <a href="classAbstract.html#a45e27d5fe7cf8a4db9e837a024b8e73e">More...</a><br /></td></tr>
<tr class="separator:a45e27d5fe7cf8a4db9e837a024b8e73e inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9687663de691e5ce2750370e0c6ab295 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a9687663de691e5ce2750370e0c6ab295">operator==</a> (int t_value) const</td></tr>
<tr class="separator:a9687663de691e5ce2750370e0c6ab295 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e08758ab4a9422c56b18af734f9ed18 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a8e08758ab4a9422c56b18af734f9ed18">operator==</a> (double t_value) const</td></tr>
<tr class="separator:a8e08758ab4a9422c56b18af734f9ed18 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e51647ab1a6ab6c1151d3b1fe00575c inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a4e51647ab1a6ab6c1151d3b1fe00575c">operator!=</a> (int t_value) const</td></tr>
<tr class="separator:a4e51647ab1a6ab6c1151d3b1fe00575c inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5d7caab7b39ed1a425456e09fe10d8 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a2d5d7caab7b39ed1a425456e09fe10d8">operator!=</a> (double t_value) const</td></tr>
<tr class="separator:a2d5d7caab7b39ed1a425456e09fe10d8 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd82f421ad221566224e1ddf22978b04 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#abd82f421ad221566224e1ddf22978b04">operator!=</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:abd82f421ad221566224e1ddf22978b04 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Compares</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another.  <a href="classAbstract.html#abd82f421ad221566224e1ddf22978b04">More...</a><br /></td></tr>
<tr class="separator:abd82f421ad221566224e1ddf22978b04 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cfb786cf54b23696ccdb0a9dd9d6ad inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a13cfb786cf54b23696ccdb0a9dd9d6ad">operator|=</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a13cfb786cf54b23696ccdb0a9dd9d6ad inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classAbstract.html#a13cfb786cf54b23696ccdb0a9dd9d6ad">More...</a><br /></td></tr>
<tr class="separator:a13cfb786cf54b23696ccdb0a9dd9d6ad inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c15e5e29f3e15ade703b1135efd20f inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#ad3c15e5e29f3e15ade703b1135efd20f">operator &amp;=</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:ad3c15e5e29f3e15ade703b1135efd20f inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classAbstract.html#ad3c15e5e29f3e15ade703b1135efd20f">More...</a><br /></td></tr>
<tr class="separator:ad3c15e5e29f3e15ade703b1135efd20f inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26068fd48ccc64453283e32c552f9e5 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#af26068fd48ccc64453283e32c552f9e5">operator&gt;</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const =0</td></tr>
<tr class="memdesc:af26068fd48ccc64453283e32c552f9e5 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classAbstract.html#af26068fd48ccc64453283e32c552f9e5">More...</a><br /></td></tr>
<tr class="separator:af26068fd48ccc64453283e32c552f9e5 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc57fa894a78c5daebc8bc3ef113740f inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#afc57fa894a78c5daebc8bc3ef113740f">operator&lt;</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const =0</td></tr>
<tr class="memdesc:afc57fa894a78c5daebc8bc3ef113740f inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classAbstract.html#afc57fa894a78c5daebc8bc3ef113740f">More...</a><br /></td></tr>
<tr class="separator:afc57fa894a78c5daebc8bc3ef113740f inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94e9a1081c5b78f63fa05ea6e379d6f inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#af94e9a1081c5b78f63fa05ea6e379d6f">operator&gt;=</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:af94e9a1081c5b78f63fa05ea6e379d6f inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classAbstract.html#af94e9a1081c5b78f63fa05ea6e379d6f">More...</a><br /></td></tr>
<tr class="separator:af94e9a1081c5b78f63fa05ea6e379d6f inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba6b588c907bb15f8daa152655e58e5 inherit pub_methods_classAbstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a3ba6b588c907bb15f8daa152655e58e5">operator&lt;=</a> (const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a3ba6b588c907bb15f8daa152655e58e5 inherit pub_methods_classAbstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classAbstract.html#a3ba6b588c907bb15f8daa152655e58e5">More...</a><br /></td></tr>
<tr class="separator:a3ba6b588c907bb15f8daa152655e58e5 inherit pub_methods_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a70b5e28b5bc3d1b63a7435c5fe50b837"><td class="memItemLeft" align="right" valign="top"><a id="a70b5e28b5bc3d1b63a7435c5fe50b837"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dim</b></td></tr>
<tr class="separator:a70b5e28b5bc3d1b63a7435c5fe50b837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1107a896b97cf72d39e26224901d1d"><td class="memItemLeft" align="right" valign="top"><a id="a5c1107a896b97cf72d39e26224901d1d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nArgs</b></td></tr>
<tr class="separator:a5c1107a896b97cf72d39e26224901d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b45f589b85c4fcd4df72ed195e230b"><td class="memItemLeft" align="right" valign="top"><a id="ab3b45f589b85c4fcd4df72ed195e230b"></a>
std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>argument</b></td></tr>
<tr class="separator:ab3b45f589b85c4fcd4df72ed195e230b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d0c7a7497d0cce539e98f089291f0d"><td class="memItemLeft" align="right" valign="top"><a id="a57d0c7a7497d0cce539e98f089291f0d"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b></td></tr>
<tr class="separator:a57d0c7a7497d0cce539e98f089291f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classAbstract"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classAbstract')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classAbstract.html">Abstract</a></td></tr>
<tr class="memitem:a9b45b3e13bd9167aab02e17e08916231 inherit pro_attribs_classAbstract"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a9b45b3e13bd9167aab02e17e08916231">name</a></td></tr>
<tr class="separator:a9b45b3e13bd9167aab02e17e08916231 inherit pro_attribs_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b736117ed72bc3d8bc6813c97ca850 inherit pro_attribs_classAbstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstract.html#a98b736117ed72bc3d8bc6813c97ca850">commutable</a></td></tr>
<tr class="separator:a98b736117ed72bc3d8bc6813c97ca850 inherit pro_attribs_classAbstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a86e9b3d2f9ab4d020ca63082e78978b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e9b3d2f9ab4d020ca63082e78978b4">&#9670;&nbsp;</a></span>addition_own()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> addition_own </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains implementation of special addition for Numerical- and Vectorial-types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Right operrand of the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two operands. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a0cf1d8170b6d7ec53b265462f8e1a552">Abstract</a>.</p>

</div>
</div>
<a id="ad7464cab53ca461aa7a8892b0dae42ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7464cab53ca461aa7a8892b0dae42ad">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a1fc3ae6bd5c6a80e9b81b27fc7b7a11a">iter</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Expr&gt;::iterator at the beginning of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a035a4c5ffac26b9ee25d38b84030cd2e">Abstract</a>.</p>

</div>
</div>
<a id="a7a6bf18a6497121de6a24684f727a88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6bf18a6497121de6a24684f727a88d">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#ac50bb217e67a9c51fa2b4322f56ec1a4">const_iter</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Expr&gt;::iterator at the beginning of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a652cef4522482a03d616e8d39749a390">Abstract</a>.</p>

</div>
</div>
<a id="acf1ccb84aa901bcbba4394444d18c633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1ccb84aa901bcbba4394444d18c633">&#9670;&nbsp;</a></span>develop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> develop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Develops</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full</td><td>If true the development is <b>recursive</b> through all the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The develop <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a7cffcbbde45509935dd3179383dfcd8c">Abstract</a>.</p>

</div>
</div>
<a id="aa8c453ee7313a36cc1c2987833a38d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c453ee7313a36cc1c2987833a38d0e">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of two <b>Vectorial</b> expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The right operand of the dot product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum _k (*this)[i,j,...,k]*expr[k,l,m,...]. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a7ac2674de22496c96d6229eae2968fdd">Abstract</a>.</p>

</div>
</div>
<a id="ac02492275aeabe839fa74aa7952e7fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02492275aeabe839fa74aa7952e7fad">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a1fc3ae6bd5c6a80e9b81b27fc7b7a11a">iter</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Expr&gt;::iterator at the end of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#ad803d52cf561b46554883cc14251788f">Abstract</a>.</p>

</div>
</div>
<a id="acbd533082e1ba5a159f746c26828f132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd533082e1ba5a159f746c26828f132">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#ac50bb217e67a9c51fa2b4322f56ec1a4">const_iter</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Expr&gt;::iterator at the end of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a77b8b381ee63c795f2ed54c36000b1ab">Abstract</a>.</p>

</div>
</div>
<a id="a9371625b49860dbbd2299b5de7043fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9371625b49860dbbd2299b5de7043fe0">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> evaluate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>Replaces all variables by their value and evaluating. This function must be used instead of <a class="el" href="classAbstract.html#abd473f3a4f62f338f5b0ee3b10453f39" title="Evaluates the value of the Abstract. ">evaluateScalar()</a> when treating not only real scalars.* In particular (x=2, y=3) x+iy evaluates to 3+ 3i whereas <a class="el" href="classAbstract.html#abd473f3a4f62f338f5b0ee3b10453f39" title="Evaluates the value of the Abstract. ">evaluateScalar()</a> would return 3. </p><dl class="section return"><dt>Returns</dt><dd>The abstract result of the evaluation. </dd></dl>

<p>Implements <a class="el" href="classAbstract.html#a02f313e9690045d548592ce82f9c365c">Abstract</a>.</p>

</div>
</div>
<a id="ad9d353d7c78473d62f37948937b41296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d353d7c78473d62f37948937b41296">&#9670;&nbsp;</a></span>factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> factor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Factors</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>This function tries to factor the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt any <b>factor</b>. This will be more involved in calculation than the other factorizing function that takes the factor as a parameter. So this function <b>must be used only</b> if we don't know the factors we want at the end. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full</td><td>If true the factorization is <b>recursive</b> through all the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a47214a866e4c0b5f9f0dcefc5aa1da39">Abstract</a>.</p>

</div>
</div>
<a id="afc5c1e823756b633e949f2fc6072e6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5c1e823756b633e949f2fc6072e6fe">&#9670;&nbsp;</a></span>factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> factor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Factors</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt a <b>particular</b> <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td><a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt which we try to factor. </td></tr>
    <tr><td class="paramname">full</td><td>If true the factorization is <b>recursive</b> through all the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a4fbe086f2cbc7fcdd072b8a29fe2abe6">Abstract</a>.</p>

</div>
</div>
<a id="ae61b5bdbc1b2651da335257b057e7491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61b5bdbc1b2651da335257b057e7491">&#9670;&nbsp;</a></span>getArgument() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getArgument </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iArg</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This function must not be called for building blocks, one must check first that the expression has arguments. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The i^{th} argument of the expression. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#aa3dab23c4d96c188bd24d38ad69eba20">Abstract</a>.</p>

</div>
</div>
<a id="ad9465ac47b8a768dec6e08daa1376777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9465ac47b8a768dec6e08daa1376777">&#9670;&nbsp;</a></span>getArgument() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getArgument </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must not be called for building blocks, one must check first that the expression has arguments. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The argument {i,j,...} of the expression. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a4af92cbaad45ffb4e114b90038cc1495">Abstract</a>.</p>

</div>
</div>
<a id="ab04856666aedc3cea3052858844947d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04856666aedc3cea3052858844947d7">&#9670;&nbsp;</a></span>getArgument() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getArgument </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must not be called for building blocks, one must check first that the expression has arguments. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The argument {i,j,...} of the expression. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a8a803192766a3af8cc52747e6be2258b">Abstract</a>.</p>

</div>
</div>
<a id="a611142e741518fc0745828678d1dfd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611142e741518fc0745828678d1dfd7f">&#9670;&nbsp;</a></span>getDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <b>dimension</b> of the object. </p>
<p>Allows to know if we are manipulating a pure scalar (i.e. that can have a real value) or something else. There is the particular case of the <a class="el" href="classImaginary.html" title="Numerical representation of i. ">Imaginary</a> <b>i</b> that is considered as a scalar for simplicity but in reality cannot be evaluated with a real. Example: 1 + <b>i</b> cannot be reduced. </p><dl class="section return"><dt>Returns</dt><dd>dim (a non memorized integer corresponding to the dimension of the abstract) </dd></dl>

<p>Implements <a class="el" href="classAbstract.html#a08975678f3024274380d3502839b0d10">Abstract</a>.</p>

</div>
</div>
<a id="a543e3e72f78bf20e1d63630404566262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543e3e72f78bf20e1d63630404566262">&#9670;&nbsp;</a></span>getNArgs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getNArgs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of arguments of the expression. If the expression is a building block (<a class="el" href="classAbstractBuildingBlock.html" title="Abstract class from which derive all building blocks of exprs, i.e. objects not function of further e...">AbstractBuildingBlock</a>), this function returns 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of arguments of the expression. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a3f9edafbda64687e956edd3710d52363">Abstract</a>.</p>

</div>
</div>
<a id="a6e4c472299ada58b0101d4e70c574105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4c472299ada58b0101d4e70c574105">&#9670;&nbsp;</a></span>getPrimaryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a8e2e97c94555dae36453ba3c507db79e">smType::PrimaryType</a> getPrimaryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <b>primary</b> <b>type</b> of <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (single number, scalar function with one argument, with multiple argumments, a <a class="el" href="classVector.html">Vector</a>, etc) in order to do special treatments or simplifications. </p><dl class="section return"><dt>Returns</dt><dd>type (a non memorized integer corresponding to the type of abstract) </dd></dl>

<p>Implements <a class="el" href="classAbstract.html#ae8ca7706d5195bafe639907377239b30">Abstract</a>.</p>

</div>
</div>
<a id="ace60e29a30276591e831a5b7c7660e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace60e29a30276591e831a5b7c7660e5d">&#9670;&nbsp;</a></span>getProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getProduct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the product of all elements in the <b>Vectorial</b> object. </p>
<dl class="section return"><dt>Returns</dt><dd>The product of all elements. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a97407d5f8eb14ece9c7335d56930640c">Abstract</a>.</p>

</div>
</div>
<a id="aa1b37ecbfc5dcafa0325439f72fdb32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b37ecbfc5dcafa0325439f72fdb32a">&#9670;&nbsp;</a></span>getShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; getShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to the shape of the tensor in the form of a std::vector of integers. </p>
<dl class="section return"><dt>Returns</dt><dd><b>shape</b>. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#acc79aa416f0937aa5c5c5ba07370a037">Abstract</a>.</p>

</div>
</div>
<a id="af94e57a145012ad9e6d75e9b33501a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94e57a145012ad9e6d75e9b33501a98">&#9670;&nbsp;</a></span>getSubVectorial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getSubVectorial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>exceptions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iExcept</td><td>Element to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The part of *this excluding iExcept. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a77756abf1144b00e44eafabd582740fe">Abstract</a>.</p>

</div>
</div>
<a id="afffa89e0d4c9e3a8bb3aa5959249ab55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffa89e0d4c9e3a8bb3aa5959249ab55">&#9670;&nbsp;</a></span>getSum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getSum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the sum of all elements in the <b>Vectorial</b> object. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of all elements. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a8ba9f54b32db597435e94cf8645175e6">Abstract</a>.</p>

</div>
</div>
<a id="aacdc998afa6abe3cd8b2f230005b3950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdc998afa6abe3cd8b2f230005b3950">&#9670;&nbsp;</a></span>getVectorArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt; &amp; getVectorArgument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to get the entire std::vector of arguments of the expression. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must not be called for building blocks, one must check first that the expression has arguments. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The std::vector of argument. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a5a7170bc22902a3964584ae8994a84b4">Abstract</a>.</p>

</div>
</div>
<a id="a8a7a92b35a50908f79ded8dd5522150f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7a92b35a50908f79ded8dd5522150f">&#9670;&nbsp;</a></span>getVectorialModulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> getVectorialModulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Vectorial modulus of the <b>Vectorial</b> object, that is defined here as the squared root of the sum of element squared. Example: {A_{11}^2+A_{12}^2+}. </p>
<dl class="section return"><dt>Returns</dt><dd>The vectorial modulus of the expression. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a3920c1dff045e546ccc0286c2c2677e8">Abstract</a>.</p>

</div>
</div>
<a id="a41679a5ac7ec7a7b338d7a240fa9a0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41679a5ac7ec7a7b338d7a240fa9a0ec">&#9670;&nbsp;</a></span>matchShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool matchShape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In the case of a vectorial-type expression, this function checks if the shape of expr matches itself. </p>
<p>If <b>exact</b> is true, the function search an exact match i.e. either the two shapes are exactly equal or one of the two objects is a scalar. If <b>exact</b> is false, this function only search for a possible dot product between the two expressions, and see if the last axis of <b>*this</b> matches the first of <b>expr</b> (or if one of the two objects is scalar also). Then, a product  _k (*this)[i,j,...,k]*expr[k,l,m,...] is possible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression of which we compare the shape. </td></tr>
    <tr><td class="paramname">exact</td><td>Boolean than specifies if we need an exact match or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two shapes correspond. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#af5e8162a13d141bbc3fe41b37f7c98e2">Abstract</a>.</p>

</div>
</div>
<a id="a3ab648a7f5b3c4bea99303a80e1cb231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab648a7f5b3c4bea99303a80e1cb231">&#9670;&nbsp;</a></span>multiplication_own()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> multiplication_own </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>side</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains implementation of special multiplication for Numerical- and Vectorial-types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Right operrand of the product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two operands. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a57a0d8a83933471cc769445a83d21e03">Abstract</a>.</p>

</div>
</div>
<a id="ac6b2bc11074fbdb41c70125a5d9bf1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b2bc11074fbdb41c70125a5d9bf1ab">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Compares</b> the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another. </p>
<p>Here if two Abstracts have the same name, the function will return <b>true</b> even if they are <b>not</b> <b>mathematically</b> <b>equal</b>. So beware not to name different things the same way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two Abstracts are the same (or have the same name). </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Implements <a class="el" href="classAbstract.html#a6659bcfd9c94a8b2605027ca77d2f8fe">Abstract</a>.</p>

</div>
</div>
<a id="a72b1c4cd3597712bc6250fc1b08d6d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b1c4cd3597712bc6250fc1b08d6d00">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access operator for multi-argument expressions, returns a reference so this function is not const. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iArg</td><td><a class="el" href="classIndex.html">Index</a> of the argument to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <b>argument</b>[iArg]. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#ae14918d3e72b9ce4cd6c873400c1fadc">Abstract</a>.</p>

</div>
</div>
<a id="afa3940fec5665747f69e980bb670a338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3940fec5665747f69e980bb670a338">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iArg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access operator for multi-argument expressions, equivalent to the function <a class="el" href="classAbstractVectorial.html#ae61b5bdbc1b2651da335257b057e7491">getArgument()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iArg</td><td><a class="el" href="classIndex.html">Index</a> of the argument to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>argument</b>[iArg]. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#ad414919cfc04dd363e211473110559c2">Abstract</a>.</p>

</div>
</div>
<a id="abd9f12af3b52f041754d10bc7f106a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9f12af3b52f041754d10bc7f106a96">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void print </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays the abstract in standard output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Tells if the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> is printed alone (default) or in another expr. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classAbstract.html#a0580f5b543391148404278629c495668">Abstract</a>.</p>

</div>
</div>
<a id="a8086e83f45a0d609ebe40a6f0a269e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8086e83f45a0d609ebe40a6f0a269e88">&#9670;&nbsp;</a></span>printLaTeX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string printLaTeX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a LaTeX output for the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Tells if the <a class="el" href="classAbstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> is printed alone (default) or in another expr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string corresponding to the LaTeX output. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#af21ac36bebac371e07ca725f91c9a21c">Abstract</a>.</p>

</div>
</div>
<a id="a41a215382d81df0b37903a55dd56d485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a215382d81df0b37903a55dd56d485">&#9670;&nbsp;</a></span>setArgument() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iArg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the argument at position <b>iArg</b> (default=0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression that replaces the argument. </td></tr>
    <tr><td class="paramname">iArg</td><td>the position of the argument to change. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a75c8c199caec4d49c81b330954228b72">Abstract</a>.</p>

</div>
</div>
<a id="a55833e40303f215acf7641c47318bb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55833e40303f215acf7641c47318bb92">&#9670;&nbsp;</a></span>setArgument() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression that replaces the argument. </td></tr>
    <tr><td class="paramname">indices</td><td>An intializer_list containing the series of indices corresponding to the argument to replace. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a61f4a9411974d0b2f61a004c79139a64">Abstract</a>.</p>

</div>
</div>
<a id="a94121f60b12f43e773d162bc1a4f2989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94121f60b12f43e773d162bc1a4f2989">&#9670;&nbsp;</a></span>setArgument() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression that replaces the argument. </td></tr>
    <tr><td class="paramname">indices</td><td>An std::vector containing the series of indices corresponding to the argument to replace. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#aaff36101861ab91916f2c617a15f7687">Abstract</a>.</p>

</div>
</div>
<a id="aa91d8c931bcc6bd05116a7001df7c158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91d8c931bcc6bd05116a7001df7c158">&#9670;&nbsp;</a></span>setVectorArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setVectorArgument </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>t_argument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the entire std::vector of argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_argument</td><td>std::vector of expressions to copy. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#ab76aaf6a94588273e3f92cf1980cf7ec">Abstract</a>.</p>

</div>
</div>
<a id="a0adf32913aa9251d725b9e8acaf5d9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adf32913aa9251d725b9e8acaf5d9ee">&#9670;&nbsp;</a></span>tensor_dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> tensor_dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tensor_dot of two <b>Vectorial</b> expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The right operand of the tensor_dot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor dot of <b>*this</b> and <b>expr</b>. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a250b633a570e586433cea97c05fcc5fe">Abstract</a>.</p>

</div>
</div>
<a id="ade105c7b96ac33d550011007c554b318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade105c7b96ac33d550011007c554b318">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="abstract_8h.html#a468d0bc0f5027352921401ec143639ae">Expr</a> trace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the trace over the axis <b>axis1</b> and <b>axis2</b> of a tensor. <b>axis1</b> and <b>axis2</b> can be the same, in which case the trace just corresponds to the sum over this particular axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis1</td><td>First axis to contract. </td></tr>
    <tr><td class="paramname">axis2</td><td>Second axis to contract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the trace over axis <b>axis1</b> and <b>axis2</b>. </dd></dl>

<p>Reimplemented from <a class="el" href="classAbstract.html#a12d7558a06855e805ab2b347c89fbab4">Abstract</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="vector_8h_source.html">vector.h</a></li>
<li>src/vector.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
